<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whiteboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* Text Editor matching styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }
        
        /* Theme Variables - Exact match to Text Editor */
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #2d2d30;
            --text-primary: #d4d4d4;
            --text-secondary: #a0a0a0;
            --border-color: #3c3c3c;
            --accent-color: #61dafb;
            --highlight-bg: #264f78;
        }
        
        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f8f8;
            --bg-tertiary: #e8e8e8;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border-color: #cccccc;
            --accent-color: #0078d4;
            --highlight-bg: #b3d9ff;
        }

        .app {
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-primary);
        }

        /* Header - Exact match to Text Editor */
        .header {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-primary));
            border-bottom: 1px solid var(--border-color);
            padding: 12px 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .menu-bar {
            display: flex;
            gap: 0;
            margin-right: 20px;
        }

        .header h1 {
            color: var(--accent-color);
            font-size: 20px;
            font-weight: 600;
        }

        .menu-item {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            position: relative;
            transition: all 0.2s ease;
        }

        .menu-item:hover {
            background-color: var(--bg-tertiary);
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            min-width: 180px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            display: none;
            z-index: 1000;
        }

        .menu-item:hover .dropdown-menu {
            display: block;
        }

        .dropdown-item {
            padding: 8px 16px;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 13px;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .dropdown-item:hover {
            background-color: var(--bg-tertiary);
        }

        /* Submenu styles for Insert > Shape */
        .dropdown-submenu {
            position: relative;
        }

        .dropdown-submenu-content {
            position: absolute;
            top: 0;
            left: 100%;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            min-width: 120px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            display: none;
            z-index: 1001;
        }

        .dropdown-submenu:hover .dropdown-submenu-content {
            display: block;
        }

        .dropdown-separator {
            height: 1px;
            background-color: var(--border-color);
            margin: 4px 0;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        /* File Tabs - Match Text Editor */
        .file-tabs {
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 5px 10px;
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .file-tab {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px 4px 0 0;
            padding: 8px 16px;
            margin-right: 2px;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 13px;
            position: relative;
        }

        .file-tab.active {
            background: var(--bg-primary);
            border-bottom-color: var(--bg-primary);
        }

        .file-tab:hover {
            background: var(--bg-tertiary);
        }

        .file-tab-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-tab-close {
            margin-left: 8px;
            cursor: pointer;
            opacity: 0.7;
        }

        .file-tab-close:hover {
            opacity: 1;
            color: var(--accent-color);
        }

        .new-file-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
        }

        .new-file-btn:hover {
            background: var(--accent-color);
        }

        /* Toolbar - Match Text Editor */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 8px;
            background-color: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .tool-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Buttons - Match Text Editor style */
        button {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button:hover {
            background: var(--accent-color);
            color: white;
        }

        .tool-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            min-width: 60px;
            transition: all 0.2s ease;
            font-size: 11px;
        }

        .tool-btn.active {
            background: var(--accent-color);
            color: white;
        }

        .tool-btn:hover {
            background: var(--accent-color);
            color: white;
        }

        .format-btn {
            background: var(--button-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 0 2px;
            min-width: 32px;
            height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        .format-btn:hover {
            background: var(--accent-color);
            color: white;
        }

        .format-btn.active {
            background: var(--accent-color);
            color: white;
        }

        #fontFamily {
            background: var(--button-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 14px;
            margin: 0 4px;
            min-width: 100px;
        }

        #fontFamily:focus {
            outline: 2px solid var(--accent-color);
            outline-offset: -2px;
        }

        .tool-separator {
            width: 1px;
            height: 30px;
            background: var(--border-color);
            margin: 0 10px;
        }

        .color-palette {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .color-btn {
            width: 28px;
            height: 28px;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .color-btn.active {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 1px var(--accent-color);
        }

        .color-btn:hover {
            border-color: var(--accent-color);
        }

        .color-picker {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            background: none;
        }

        /* Drawing Canvas Container */
        .drawing-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        #drawingCanvas {
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            cursor: crosshair;
        }

        /* Status Bar - Match Text Editor */
        .status-bar {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 5px 10px;
            display: flex;
            gap: 20px;
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 10px;
        }

        /* Range input styling */
        input[type="range"] {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            height: 20px;
        }

        /* Label styling */
        label {
            color: var(--text-primary);
            font-size: 13px;
        }

        /* Span styling for size display */
        #sizeDisplay, #currentTool, #currentSizeDisplay {
            color: var(--accent-color);
            font-weight: 500;
        }
    </style>
</head>
<body data-theme="dark">
    <div class="app">
        <!-- Header -->
        <div class="header">
            <div class="menu-bar">
        <div class="menu-item">
            File
            <div class="dropdown-menu">
                <button class="dropdown-item" onclick="clearCanvas()">New</button>
                <button class="dropdown-item" onclick="loadWhiteboard()">Open</button>
                <button class="dropdown-item" onclick="saveWhiteboard()">Save</button>
            </div>
        </div>
        <div class="menu-item">
            Edit
            <div class="dropdown-menu">
                <button class="dropdown-item" onclick="undoDrawing()">Undo</button>
                <button class="dropdown-item" onclick="redoDrawing()">Redo</button>
                <button class="dropdown-item" onclick="clearCanvas()">Clear All</button>
            </div>
        </div>
        <div class="menu-item">
            Insert
            <div class="dropdown-menu">
                <button class="dropdown-item" onclick="setDrawingTool('rectangle')">Rectangle</button>
                <button class="dropdown-item" onclick="setDrawingTool('circle')">Circle</button>
                <button class="dropdown-item" onclick="setDrawingTool('line')">Line</button>
                <button class="dropdown-item" onclick="setDrawingTool('arrow')">Arrow</button>
                <button class="dropdown-item" onclick="setDrawingTool('double-arrow')">Double Arrow</button>
            </div>
        </div>
        <div class="menu-item">
            View
            <div class="dropdown-menu">
                <button class="dropdown-item" onclick="toggleTheme()">Toggle Theme</button>
            </div>
        </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- File Tabs -->
            <div class="file-tabs" id="fileTabs">
                <button class="new-file-btn" onclick="newWhiteboard()">+</button>
            </div>

            <!-- Drawing Tools Toolbar -->
            <div class="toolbar">
                <div class="tool-group">
                    <button id="penTool" class="tool-btn active" onclick="setDrawingTool('pen')">
                        <span>‚úèÔ∏è</span>Pen
                    </button>
                    <button id="eraserTool" class="tool-btn" onclick="setDrawingTool('eraser')">
                        <span>üßπ</span>Eraser
                    </button>
                    <button id="textTool" class="tool-btn" onclick="setDrawingTool('text')">
                        <span>Aa</span>Text
                    </button>
                </div>
                
                <div class="tool-separator"></div>
                
                <!-- Pen Tool Controls -->
                <div id="penControls" class="tool-group" style="display: flex;">
                    <div class="color-palette">
                        <button class="color-btn active" style="background: #ff0000;" onclick="setDrawingColor('#ff0000')" title="Red"></button>
                        <button class="color-btn" style="background: #0000ff;" onclick="setDrawingColor('#0000ff')" title="Blue"></button>
                        <button class="color-btn" style="background: #00ff00;" onclick="setDrawingColor('#00ff00')" title="Green"></button>
                        <input type="color" class="color-picker" onchange="selectCustomColor(this)" title="Custom Color">
                    </div>
                </div>
                
                <div id="penSeparator1" class="tool-separator" style="display: flex;"></div>
                
                <div id="penSizeControls" class="tool-group" style="display: flex;">
                    <input type="range" id="brushSize" min="1" max="20" value="3" onchange="setBrushSize(this.value)">
                    <span id="sizeDisplay">3px</span>
                </div>
                
                <div id="penSeparator2" class="tool-separator" style="display: flex;"></div>
                
                <div id="penAlphaControls" class="tool-group" style="display: flex;">
                    <label for="penAlpha">Opacity:</label>
                    <input type="range" id="penAlpha" min="0.1" max="1" step="0.1" value="1" onchange="setPenAlpha(this.value)">
                    <span id="alphaDisplay">100%</span>
                </div>
                
                <!-- Eraser Tool Controls -->
                <div id="eraserControls" class="tool-group" style="display: none;">
                    <input type="range" id="eraserSize" min="5" max="50" value="15" onchange="setEraserSize(this.value)">
                    <span id="eraserSizeDisplay">15px</span>
                </div>
                
                <!-- Text Tool Controls -->
                <div id="textControls" class="tool-group" style="display: none;">
                    <select id="fontFamily" onchange="setFontFamily(this.value)">
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                    </select>
                </div>
                
                <div id="textSeparator1" class="tool-separator" style="display: none;"></div>
                
                <div id="textSizeControls" class="tool-group" style="display: none;">
                    <input type="range" id="fontSizeSlider" min="10" max="72" value="16" onchange="setFontSize(this.value)">
                    <span id="fontSizeDisplay">16px</span>
                </div>
                
                <div id="textSeparator2" class="tool-separator" style="display: none;"></div>
                
                <div id="textFormatControls" class="tool-group" style="display: none;">
                    <button id="boldButton" class="format-btn" onclick="toggleTextFormat('bold')" onmousedown="event.preventDefault()" title="Bold">
                        <strong>B</strong>
                    </button>
                    <button id="italicButton" class="format-btn" onclick="toggleTextFormat('italic')" onmousedown="event.preventDefault()" title="Italic">
                        <em>I</em>
                    </button>
                </div>
                
                <div id="textSeparator3" class="tool-separator" style="display: none;"></div>
                
                <div id="textColorControls" class="tool-group" style="display: none;">
                    <div class="color-palette">
                        <button class="color-btn text-color-btn active" style="background: #ff0000;" onclick="setDrawingColor('#ff0000')" title="Red"></button>
                        <button class="color-btn text-color-btn" style="background: #0000ff;" onclick="setDrawingColor('#0000ff')" title="Blue"></button>
                        <button class="color-btn text-color-btn" style="background: #00ff00;" onclick="setDrawingColor('#00ff00')" title="Green"></button>
                        <input type="color" class="color-picker" onchange="selectCustomColor(this)" title="Custom Color">
                    </div>
                </div>
            </div>

            <!-- Drawing Canvas -->
            <div class="drawing-container">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <!-- Status Bar -->
            <div class="status-bar">
                <span>Mode: Whiteboard</span>
                <span>Tool: <span id="currentTool">Pen</span></span>
                <span>Size: <span id="currentSizeDisplay">3px</span></span>
                <span>Canvas: <span id="canvasSize">Loading...</span></span>
                <span>Zoom: <span id="zoomDisplay">100%</span></span>
                <span>Pan: Ctrl+Wheel or Ctrl+Shift+Drag</span>
            </div>
        </div>
    </div>

    <script>
        // Drawing functionality
        let canvas, ctx;
        let tempCanvas, tempCtx; // For transparent drawing
        let isDrawing = false;
        let currentTool = 'pen';
        let currentColor = '#ff0000';
        let currentSize = 3;
        let penAlpha = 1;
        let lastX, lastY;
        
        // Undo/Redo state management
        let drawingHistory = [];
        let historyStep = -1;
        let isRestoring = false;
        
        // Text tool specific variables
        let textBoxes = [];
        let activeTextBox = null;
        let textInput = null;
        let fontSize = 16; // Initialize with default value
        
        // Eraser specific variables
        let eraserSize = 15;
        
        // Shape tool variables
        let shapes = [];
        let isDrawingShape = false;
        let startX, startY;
        let copiedShape = null;
        
        // Shape manipulation variables
        let selectedShape = null;
        let isDragging = false;
        let isResizing = false;
        let resizeHandle = null;
        let dragOffsetX = 0, dragOffsetY = 0;
        let rotationStartAngle = 0;
        let shapeStartAngle = 0;
        
        // Viewport variables for infinite scroll
        let viewportX = 0;
        let viewportY = 0;
        let zoomLevel = 1;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let lastPanX = 0;
        let lastPanY = 0;
        
        // File management
        let whiteboards = [{
            id: 'whiteboard_0',
            name: 'Untitled.png',
            data: null,
            modified: false
        }];
        let activeWhiteboardId = 'whiteboard_0';
        let whiteboardCounter = 1;
        
        function getCurrentWhiteboard() {
            return whiteboards.find(wb => wb.id === activeWhiteboardId);
        }
        
        function newWhiteboard() {
            const newId = 'whiteboard_' + whiteboardCounter++;
            const newWhiteboard = {
                id: newId,
                name: `Untitled${whiteboardCounter - 1}.png`,
                data: null,
                modified: false
            };
            whiteboards.push(newWhiteboard);
            switchToWhiteboard(newId);
            renderWhiteboardTabs();
        }
        
        function switchToWhiteboard(whiteboardId) {
            // Save current whiteboard state
            if (canvas) {
                const currentWb = getCurrentWhiteboard();
                if (currentWb) {
                    currentWb.data = canvas.toDataURL();
                }
            }
            
            activeWhiteboardId = whiteboardId;
            renderWhiteboardTabs();
            
            // Load the switched whiteboard
            const targetWb = getCurrentWhiteboard();
            if (targetWb && targetWb.data && canvas) {
                const img = new Image();
                img.onload = function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = targetWb.data;
            } else if (canvas) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }
        
        function closeWhiteboard(whiteboardId) {
            if (whiteboards.length <= 1) return; // Keep at least one whiteboard
            
            const index = whiteboards.findIndex(wb => wb.id === whiteboardId);
            if (index !== -1) {
                whiteboards.splice(index, 1);
                
                // If closing active whiteboard, switch to another
                if (activeWhiteboardId === whiteboardId) {
                    const newActiveIndex = Math.min(index, whiteboards.length - 1);
                    switchToWhiteboard(whiteboards[newActiveIndex].id);
                } else {
                    renderWhiteboardTabs();
                }
            }
        }
        
        function renderWhiteboardTabs() {
            const tabsContainer = document.getElementById('fileTabs');
            const newFileBtn = tabsContainer.querySelector('.new-file-btn');
            
            // Clear existing tabs but keep new file button
            tabsContainer.innerHTML = '';
            tabsContainer.appendChild(newFileBtn);
            
            // Add tabs for each whiteboard
            whiteboards.forEach(wb => {
                const tab = document.createElement('div');
                tab.className = `file-tab ${wb.id === activeWhiteboardId ? 'active' : ''}`;
                tab.onclick = (e) => {
                    if (!e.target.classList.contains('file-tab-close')) {
                        switchToWhiteboard(wb.id);
                    }
                };
                
                tab.innerHTML = `
                    <span class="file-tab-name">${wb.name}${wb.modified ? ' ‚Ä¢' : ''}</span>
                    ${whiteboards.length > 1 ? `<span class="file-tab-close" onclick="event.stopPropagation(); closeWhiteboard('${wb.id}');">√ó</span>` : ''}
                `;
                
                tabsContainer.appendChild(tab);
            });
        }

        function initCanvas() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');
            
            // Create off-screen canvas for transparent drawing
            tempCanvas = document.createElement('canvas');
            tempCtx = tempCanvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = currentSize;
            ctx.strokeStyle = currentColor;
            ctx.globalCompositeOperation = 'source-over';
            
            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            // Add mouse move for cursor changes
            canvas.addEventListener('mousemove', updateCursor);
            
            // Add wheel event for zoom and pan
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            
            // Touch events
            canvas.addEventListener('touchstart', startDrawing);
            canvas.addEventListener('touchmove', draw);
            canvas.addEventListener('touchend', stopDrawing);
            
            // Only finalize text when clicking outside the input area
            document.addEventListener('mousedown', function(e) {
                if (currentTool === 'text' && activeTextBox && textInput) {
                    // Only finalize if clicking completely outside the text input
                    if (e.target !== textInput && 
                        e.target.getAttribute('data-text-input') !== 'true' &&
                        !textInput.contains(e.target)) {
                        finalizeTextInput();
                    }
                }
            });
            
            // Save initial state
            saveState();
            
            // Add keyboard shortcuts
            document.addEventListener('keydown', handleKeyboardShortcuts);
            
            // Add global click handler to clear selection when clicking outside
            document.addEventListener('click', handleGlobalClick);
        }
        
        // Coordinate transformation functions
        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX / zoomLevel) + viewportX,
                y: (screenY / zoomLevel) + viewportY
            };
        }
        
        function worldToScreen(worldX, worldY) {
            return {
                x: (worldX - viewportX) * zoomLevel,
                y: (worldY - viewportY) * zoomLevel
            };
        }
        
        function applyTransform() {
            ctx.setTransform(zoomLevel, 0, 0, zoomLevel, -viewportX * zoomLevel, -viewportY * zoomLevel);
        }
        
        function resetTransform() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
        
        function handleWheel(e) {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Convert to world coordinates before zoom
            const worldPos = screenToWorld(mouseX, mouseY);
            
            if (e.ctrlKey) {
                // Zoom
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                zoomLevel *= zoomFactor;
                zoomLevel = Math.max(0.1, Math.min(5, zoomLevel)); // Limit zoom
                
                // Adjust viewport to zoom towards mouse position
                const newScreenPos = worldToScreen(worldPos.x, worldPos.y);
                viewportX += (mouseX - newScreenPos.x) / zoomLevel;
                viewportY += (mouseY - newScreenPos.y) / zoomLevel;
            } else {
                // Pan
                const panSpeed = 50;
                viewportX += (e.deltaX / zoomLevel) * (panSpeed / 100);
                viewportY += (e.deltaY / zoomLevel) * (panSpeed / 100);
            }
            
            redrawCanvas();
        }

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // Resize off-screen canvas to match
            tempCanvas.width = rect.width;
            tempCanvas.height = rect.height;
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = currentSize;
            ctx.strokeStyle = currentColor;
            
            // Set up temp canvas
            tempCtx.lineCap = 'round';
            tempCtx.lineJoin = 'round';
            
            updateCanvasSize();
        }

        function startDrawing(e) {
            if (currentTool === 'text') {
                handleTextClick(e);
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            const screenX = (e.clientX || e.touches[0].clientX) - rect.left;
            const screenY = (e.clientY || e.touches[0].clientY) - rect.top;
            const worldPos = screenToWorld(screenX, screenY);
            const x = worldPos.x;
            const y = worldPos.y;
            
            // Check for space key + mouse for panning
            if (e.button === 1 || (e.button === 0 && e.ctrlKey && e.shiftKey)) { // Middle mouse or Ctrl+Shift+Left mouse
                isPanning = true;
                panStartX = screenX;
                panStartY = screenY;
                lastPanX = viewportX;
                lastPanY = viewportY;
                canvas.style.cursor = 'grabbing';
                return;
            }
            
            // Handle shape tools
            if (currentTool === 'rectangle' || currentTool === 'circle' || currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow') {
                // Check if clicking on existing shape first
                const clickedShape = findShapeAt(x, y);
                if (clickedShape) {
                    // Only select this shape, clear any previous selection
                    selectedShape = clickedShape;
                    // Check if clicking on resize/rotation handle
                    const handle = getResizeHandle(x, y, clickedShape);
                    if (handle === 'rotate') {
                        isResizing = true;
                        resizeHandle = 'rotate';
                        // Calculate rotation center based on corrected selection bounds
                        let selectionX, selectionY, selectionWidth, selectionHeight;
                        if (clickedShape.type === 'line' || clickedShape.type === 'arrow' || clickedShape.type === 'double-arrow') {
                            const startX = clickedShape.x;
                            const startY = clickedShape.y;
                            const endX = clickedShape.width;
                            const endY = clickedShape.height;
                            selectionX = Math.min(startX, endX) - 10;
                            selectionY = Math.min(startY, endY) - 10;
                            selectionWidth = Math.abs(endX - startX) + 20;
                            selectionHeight = Math.abs(endY - startY) + 20;
                            if (selectionWidth < 40) {
                                selectionX -= (40 - selectionWidth) / 2;
                                selectionWidth = 40;
                            }
                            if (selectionHeight < 40) {
                                selectionY -= (40 - selectionHeight) / 2;
                                selectionHeight = 40;
                            }
                        } else {
                            selectionX = clickedShape.x - 3;
                            selectionY = clickedShape.y - 3;
                            selectionWidth = clickedShape.width + 6;
                            selectionHeight = clickedShape.height + 6;
                        }
                        const centerX = selectionX + selectionWidth/2;
                        const centerY = selectionY + selectionHeight/2;
                        rotationStartAngle = Math.atan2(y - centerY, x - centerX);
                        shapeStartAngle = clickedShape.angle || 0;
                    } else if (handle) {
                        isResizing = true;
                        resizeHandle = handle;
                    } else {
                        // Start dragging the shape
                        isDragging = true;
                        dragOffsetX = x - clickedShape.x;
                        dragOffsetY = y - clickedShape.y;
                    }
                    redrawCanvas();
                    return;
                }
                
                // No shape clicked, clear selection and start drawing new shape
                selectedShape = null;
                isDrawingShape = true;
                startX = x;
                startY = y;
                redrawCanvas();
                return;
            }
            
            // Handle clicking empty space (no shape found) with non-shape tools
            if (selectedShape) {
                selectedShape = null;
                redrawCanvas();
            }
            
            if (currentTool === 'pen' || currentTool === 'eraser') {
                isDrawing = true;
                lastX = x;
                lastY = y;
                
                // Set up drawing context for pen/eraser
                if (currentTool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = eraserSize;
                    ctx.globalAlpha = 1;
                } else {
                    // For pen with transparency, use off-screen canvas
                    if (penAlpha < 1) {
                        tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                        tempCtx.globalCompositeOperation = 'source-over';
                        tempCtx.lineWidth = currentSize;
                        tempCtx.strokeStyle = currentColor;
                        tempCtx.globalAlpha = 1; // Draw solid on temp canvas
                    } else {
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.lineWidth = currentSize;
                        ctx.strokeStyle = currentColor;
                        ctx.globalAlpha = 1;
                    }
                }
                
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                // Don't save state here for pen/eraser, save only when drawing is complete
            }
        }

        function updateCursor(e) {
            // Don't change cursor while drawing/dragging/resizing
            if (isDrawing || isDragging || isResizing || isDrawingShape) return;
            
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const worldPos = screenToWorld(screenX, screenY);
            const x = worldPos.x;
            const y = worldPos.y;
            
            // Check if we're over a shape manipulation tool
            if (currentTool === 'rectangle' || currentTool === 'circle' || currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow') {
                const hoveredShape = findShapeAt(x, y);
                
                if (hoveredShape) {
                    const handle = getResizeHandle(x, y, hoveredShape);
                    
                    if (handle === 'rotate') {
                        canvas.style.cursor = 'grab';
                        canvas.title = 'Drag to rotate shape';
                    } else if (handle === 'nw' || handle === 'se') {
                        canvas.style.cursor = 'nw-resize';
                        canvas.title = 'Drag to resize';
                    } else if (handle === 'ne' || handle === 'sw') {
                        canvas.style.cursor = 'ne-resize';
                        canvas.title = 'Drag to resize';
                    } else {
                        // Over shape but not on handle - can move
                        canvas.style.cursor = 'move';
                        canvas.title = 'Drag to move shape';
                    }
                } else {
                    // Not over any shape - crosshair for drawing
                    canvas.style.cursor = 'crosshair';
                    canvas.title = 'Click and drag to draw new shape';
                }
            } else {
                // Restore default cursor for other tools
                if (currentTool === 'pen') {
                    canvas.style.cursor = 'crosshair';
                    canvas.title = 'Draw with pen';
                } else if (currentTool === 'eraser') {
                    canvas.style.cursor = 'grab';
                    canvas.title = 'Erase content';
                } else if (currentTool === 'text') {
                    canvas.style.cursor = 'text';
                    canvas.title = 'Click to add text';
                }
            }
        }
        
        function draw(e) {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const screenX = (e.clientX || e.touches[0].clientX) - rect.left;
            const screenY = (e.clientY || e.touches[0].clientY) - rect.top;
            
            // Handle viewport panning
            if (isPanning) {
                const deltaX = screenX - panStartX;
                const deltaY = screenY - panStartY;
                viewportX = lastPanX - (deltaX / zoomLevel);
                viewportY = lastPanY - (deltaY / zoomLevel);
                redrawCanvas();
                return;
            }
            
            const worldPos = screenToWorld(screenX, screenY);
            const currentX = worldPos.x;
            const currentY = worldPos.y;
            
            // Handle shape dragging
            if (isDragging && selectedShape) {
                canvas.style.cursor = 'move';
                selectedShape.x = currentX - dragOffsetX;
                selectedShape.y = currentY - dragOffsetY;
                redrawCanvas();
                return;
            }
            
            // Handle shape resizing
            if (isResizing && selectedShape && resizeHandle) {
                if (resizeHandle === 'rotate') {
                    canvas.style.cursor = 'grab';
                    // Calculate rotation angle properly
                    let selectionX, selectionY, selectionWidth, selectionHeight;
                    if (selectedShape.type === 'line' || selectedShape.type === 'arrow' || selectedShape.type === 'double-arrow') {
                        const startX = selectedShape.x;
                        const startY = selectedShape.y;
                        const endX = selectedShape.width;
                        const endY = selectedShape.height;
                        selectionX = Math.min(startX, endX) - 10;
                        selectionY = Math.min(startY, endY) - 10;
                        selectionWidth = Math.abs(endX - startX) + 20;
                        selectionHeight = Math.abs(endY - startY) + 20;
                        if (selectionWidth < 40) {
                            selectionX -= (40 - selectionWidth) / 2;
                            selectionWidth = 40;
                        }
                        if (selectionHeight < 40) {
                            selectionY -= (40 - selectionHeight) / 2;
                            selectionHeight = 40;
                        }
                    } else {
                        selectionX = selectedShape.x - 3;
                        selectionY = selectedShape.y - 3;
                        selectionWidth = selectedShape.width + 6;
                        selectionHeight = selectedShape.height + 6;
                    }
                    const centerX = selectionX + selectionWidth / 2;
                    const centerY = selectionY + selectionHeight / 2;
                    const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
                    const angleDiff = currentAngle - rotationStartAngle;
                    selectedShape.angle = shapeStartAngle + angleDiff;
                } else {
                    // Set appropriate resize cursor
                    if (resizeHandle === 'nw' || resizeHandle === 'se') {
                        canvas.style.cursor = 'nw-resize';
                    } else if (resizeHandle === 'ne' || resizeHandle === 'sw') {
                        canvas.style.cursor = 'ne-resize';
                    }
                    resizeShape(selectedShape, currentX, currentY, resizeHandle);
                }
                redrawCanvas();
                return;
            }
            
            // Handle new shape drawing preview
            if (isDrawingShape && (currentTool === 'rectangle' || currentTool === 'circle' || currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow')) {
                redrawCanvas();
                drawShapePreview(startX, startY, currentX, currentY);
                return;
            }
            
            // Handle regular drawing (pen, eraser)
            if (currentTool === 'text' || !isDrawing) return;
            
            // Choose the right canvas context
            const drawCtx = (currentTool === 'pen' && penAlpha < 1) ? tempCtx : ctx;
            
            // Use world coordinates directly with canvas transformation
            if (drawCtx === ctx) {
                resetTransform();
                applyTransform();
            } else {
                // Apply same transform to temp canvas
                tempCtx.setTransform(zoomLevel, 0, 0, zoomLevel, -viewportX * zoomLevel, -viewportY * zoomLevel);
            }
            
            drawCtx.beginPath();
            drawCtx.moveTo(lastX, lastY);
            drawCtx.lineTo(currentX, currentY);
            drawCtx.stroke();
            
            if (drawCtx === ctx) {
                resetTransform();
            } else {
                tempCtx.setTransform(1, 0, 0, 1, 0, 0);
            }
            
            lastX = currentX;
            lastY = currentY;
        }

        function stopDrawing(e) {
            // Handle panning end
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = 'default';
                return;
            }
            // Handle new shape creation
            if (isDrawingShape) {
                const rect = canvas.getBoundingClientRect();
                const endScreenX = (e.clientX || e.touches[0].clientX) - rect.left;
                const endScreenY = (e.clientY || e.touches[0].clientY) - rect.top;
                const endWorldPos = screenToWorld(endScreenX, endScreenY);
                const endX = endWorldPos.x;
                const endY = endWorldPos.y;
                
                if (Math.abs(endX - startX) > 5 || Math.abs(endY - startY) > 5) {
                    const shape = {
                        type: currentTool,
                        x: currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow' ? startX : Math.min(startX, endX),
                        y: currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow' ? startY : Math.min(startY, endY),
                        width: currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow' ? endX : Math.abs(endX - startX),
                        height: currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow' ? endY : Math.abs(endY - startY),
                        color: currentColor,
                        lineWidth: currentSize,
                        angle: 0,
                        id: Date.now()
                    };
                    shapes.push(shape);
                    // Don't auto-select the new shape to avoid unwanted behavior
                    // selectedShape = shape;
                    redrawCanvas();
                }
                isDrawingShape = false;
                saveState();
                return;
            }
            
            // Handle shape manipulation end
            if (isDragging || isResizing) {
                isDragging = false;
                isResizing = false;
                resizeHandle = null;
                // Reset cursor to default for the current tool
                if (currentTool === 'rectangle' || currentTool === 'circle' || currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow') {
                    canvas.style.cursor = 'crosshair';
                }
                saveState();
                return;
            }
            
            // Handle regular drawing end
            if (isDrawing) {
                isDrawing = false;
                
                // If we used temp canvas, composite it to main canvas with transparency
                if (currentTool === 'pen' && penAlpha < 1) {
                    ctx.globalAlpha = penAlpha;
                    ctx.drawImage(tempCanvas, 0, 0);
                    ctx.globalAlpha = 1;
                }
                
                // For pen/eraser, save state after drawing is complete
                if (currentTool === 'pen' || currentTool === 'eraser') {
                    // Save the current canvas state including pen/eraser strokes
                    resetTransform();
                    const tempImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    historyStep++;
                    if (historyStep < drawingHistory.length) {
                        drawingHistory.length = historyStep;
                    }
                    
                    drawingHistory[historyStep] = {
                        imageData: tempImageData,
                        textBoxes: JSON.parse(JSON.stringify(textBoxes)),
                        shapes: JSON.parse(JSON.stringify(shapes))
                    };
                    
                    if (drawingHistory.length > 20) {
                        drawingHistory.shift();
                        historyStep--;
                    }
                }
                
                const currentWb = getCurrentWhiteboard();
                if (currentWb) {
                    currentWb.modified = true;
                    renderWhiteboardTabs();
                }
            }
        }

        function handleGlobalClick(e) {
            // Don't clear selection if clicking on canvas (handled by startDrawing)
            if (e.target === canvas) return;
            
            // Don't clear if clicking on text input elements
            if (e.target.getAttribute && e.target.getAttribute('data-text-input') === 'true') return;
            if (e.target.closest && e.target.closest('[data-text-container]')) return;
            
            // Don't clear if we're currently dragging or resizing
            if (isDragging || isResizing) return;
            
            // Clear selection when clicking anywhere else (buttons, menus, toolbar, etc.)
            if (selectedShape) {
                selectedShape = null;
                redrawCanvas();
            }
        }

        function setDrawingTool(tool) {
            // Finalize any active text editing when switching tools
            if (activeTextBox && textInput && currentTool === 'text') {
                finalizeTextInput();
            }
            
            // Clear selection when switching tools
            if (selectedShape) {
                selectedShape = null;
                redrawCanvas();
            }
            
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            
            const toolBtn = document.getElementById(tool + 'Tool');
            if (toolBtn) {
                toolBtn.classList.add('active');
            }
            
            // Show/hide appropriate controls
            showToolControls(tool);
            
            if (tool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = eraserSize;
            } else if (tool === 'rectangle' || tool === 'circle' || tool === 'line' || tool === 'arrow' || tool === 'double-arrow') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = currentSize;
                ctx.strokeStyle = currentColor;
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = currentSize;
                if (currentTool === 'pen') {
                    updateColorWithAlpha();
                } else {
                    ctx.strokeStyle = currentColor;
                }
            }
            
            // Set initial cursor for the tool
            if (tool === 'eraser') {
                canvas.style.cursor = 'grab';
            } else if (tool === 'text') {
                canvas.style.cursor = 'text';
            } else {
                canvas.style.cursor = 'crosshair';
            }
            
            ctx.strokeStyle = currentColor;
            
            document.getElementById('currentTool').textContent = tool.charAt(0).toUpperCase() + tool.slice(1);
        }
        
        function showToolControls(tool) {
            // Hide all tool controls first
            const allControls = ['penControls', 'penSeparator1', 'penSizeControls', 
                                 'penSeparator2', 'penAlphaControls',
                                 'eraserControls', 'textControls', 'textSeparator1', 
                                 'textSizeControls', 'textSeparator2', 'textFormatControls',
                                 'textSeparator3', 'textColorControls'];
            
            allControls.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.style.display = 'none';
            });
            
            // Show relevant controls based on tool
            switch(tool) {
                case 'pen':
                    document.getElementById('penControls').style.display = 'flex';
                    document.getElementById('penSeparator1').style.display = 'flex';
                    document.getElementById('penSizeControls').style.display = 'flex';
                    document.getElementById('penSeparator2').style.display = 'flex';
                    document.getElementById('penAlphaControls').style.display = 'flex';
                    break;
                case 'eraser':
                    document.getElementById('eraserControls').style.display = 'flex';
                    break;
                case 'text':
                    document.getElementById('textControls').style.display = 'flex';
                    document.getElementById('textSeparator1').style.display = 'flex';
                    document.getElementById('textSizeControls').style.display = 'flex';
                    document.getElementById('textSeparator2').style.display = 'flex';
                    document.getElementById('textFormatControls').style.display = 'flex';
                    document.getElementById('textSeparator3').style.display = 'flex';
                    document.getElementById('textColorControls').style.display = 'flex';
                    break;
            }
        }

        function setDrawingColor(color) {
            currentColor = color;
            
            // Apply alpha if using pen tool
            if (currentTool === 'pen') {
                updateColorWithAlpha();
            } else {
                ctx.strokeStyle = color;
            }
            
            // Update active text input color if text tool is active
            if (currentTool === 'text' && textInput && activeTextBox) {
                textInput.style.color = color;
                textInput.style.borderColor = color;
                activeTextBox.color = color;
            }
            
            document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.color-btn').forEach(btn => {
                const btnColor = btn.style.backgroundColor || btn.style.background;
                const targetColor = color.toLowerCase();
                
                if (btnColor === targetColor || btnColor.replace(/\s/g, '') === targetColor.replace(/\s/g, '')) {
                    btn.classList.add('active');
                }
            });
        }

        function selectCustomColor(colorInput) {
            setDrawingColor(colorInput.value);
            // Clear active state from all color buttons (both pen and text)
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            // No need to set any button as active since this is a custom color
        }

        function setBrushSize(size) {
            currentSize = size;
            document.getElementById('sizeDisplay').textContent = size + 'px';
            document.getElementById('currentSizeDisplay').textContent = size + 'px';
            
            // Update canvas line width if pen is currently active
            if (currentTool === 'pen') {
                ctx.lineWidth = currentSize;
            }
        }
        
        function setPenAlpha(alpha) {
            penAlpha = parseFloat(alpha);
            document.getElementById('alphaDisplay').textContent = Math.round(alpha * 100) + '%';
            
            // Update current color with new alpha
            updateColorWithAlpha();
        }
        
        function updateColorWithAlpha() {
            if (currentTool === 'pen') {
                // Use solid color, transparency handled by globalAlpha
                ctx.strokeStyle = currentColor;
            }
        }
        
        function setFontSize(size) {
            fontSize = parseInt(size);
            document.getElementById('fontSizeDisplay').textContent = size + 'px';
            
            // Update current text input if active
            if (textInput && activeTextBox) {
                textInput.style.fontSize = fontSize + 'px';
                activeTextBox.fontSize = fontSize;
                // Trigger resize
                setTimeout(() => {
                    if (textInput) {
                        const event = new Event('input');
                        textInput.dispatchEvent(event);
                    }
                }, 10);
            }
        }

        // Text formatting state
        let textBold = false;
        let textItalic = false;
        let fontFamily = 'Arial';
        
        function setFontFamily(family) {
            fontFamily = family;
            
            // Update current text input if active
            if (textInput && activeTextBox) {
                textInput.style.fontFamily = family;
                activeTextBox.fontFamily = family;
            }
        }
        
        function setEraserSize(size) {
            eraserSize = parseInt(size);
            document.getElementById('eraserSizeDisplay').textContent = size + 'px';
            
            // Update canvas line width if eraser is currently active
            if (currentTool === 'eraser') {
                ctx.lineWidth = eraserSize;
            }
        }

        function toggleTextFormat(format) {
            const button = document.getElementById(format + 'Button');
            
            // Toggle global formatting for new text
            if (format === 'bold') {
                textBold = !textBold;
                button.classList.toggle('active', textBold);
            } else if (format === 'italic') {
                textItalic = !textItalic;
                button.classList.toggle('active', textItalic);
            }
            
            // Update current text input if active
            if (textInput && activeTextBox) {
                updateTextStyle(textInput, activeTextBox);
            }
        }

        function updateTextStyle(input, textBox) {
            if (!input || !textBox) return;
            
            let fontStyle = 'normal';
            let fontWeight = 'normal';
            
            if (textBold) fontWeight = 'bold';
            if (textItalic) fontStyle = 'italic';
            
            input.style.fontWeight = fontWeight;
            input.style.fontStyle = fontStyle;
            
            // Store formatting in textBox
            textBox.bold = textBold;
            textBox.italic = textItalic;
        }
        
        // Text tool functions
        function handleTextClick(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Don't create new input if clicking on existing text input
            if (e.target && e.target.getAttribute('data-text-input') === 'true') {
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX || e.touches[0].clientX) - rect.left;
            const canvasY = (e.clientY || e.touches[0].clientY) - rect.top;
            
            // Transform coordinates to account for zoom and viewport offset
            const x = (canvasX / zoomLevel) + viewportX;
            const y = (canvasY / zoomLevel) + viewportY;
            
            // Check if clicking on existing text first
            const existingText = findTextAt(x, y);
            if (existingText) {
                if (activeTextBox && textInput) {
                    finalizeTextInput();
                }
                setTimeout(() => editExistingText(existingText), 50);
                return;
            }
            
            // Finalize any current text input first
            if (activeTextBox && textInput) {
                finalizeTextInput();
                setTimeout(() => createTextInput(x, y), 50);
                return;
            }
            
            // Create new text input
            createTextInput(x, y);
        }
        
        function findTextAt(x, y) {
            for (let i = textBoxes.length - 1; i >= 0; i--) {
                const textBox = textBoxes[i];
                
                // Calculate text dimensions for multiline text with proper formatting
                ctx.save();
                let fontString = '';
                if (textBox.bold) fontString += 'bold ';
                if (textBox.italic) fontString += 'italic ';
                fontString += (textBox.fontSize || fontSize) + 'px ' + (textBox.fontFamily || 'Arial') + ', sans-serif';
                ctx.font = fontString;
                
                const lines = textBox.text.split('\n');
                const lineHeight = (textBox.fontSize || fontSize) * 1.2;
                let maxWidth = 0;
                
                // Find the widest line
                lines.forEach(line => {
                    const lineWidth = ctx.measureText(line).width;
                    maxWidth = Math.max(maxWidth, lineWidth);
                });
                
                const totalHeight = lines.length * lineHeight;
                
                ctx.restore();
                
                // Check if click is within text bounds
                const textBounds = {
                    left: textBox.x,
                    right: textBox.x + maxWidth,
                    top: textBox.y - (textBox.fontSize || fontSize),
                    bottom: textBox.y - (textBox.fontSize || fontSize) + totalHeight
                };
                
                if (x >= textBounds.left && x <= textBounds.right &&
                    y >= textBounds.top && y <= textBounds.bottom) {
                    return textBox;
                }
            }
            return null;
        }
        
        function createTextInput(x, y) {
            saveState();
            
            // Create textarea element for multiline support
            textInput = document.createElement('textarea');
            textInput.style.position = 'absolute';
            
            // Convert world coordinates to screen coordinates for positioning  
            const screenPos = worldToScreen(x, y);
            textInput.style.left = (canvas.getBoundingClientRect().left + window.scrollX + screenPos.x) + 'px';
            textInput.style.top = (canvas.getBoundingClientRect().top + window.scrollY + screenPos.y - fontSize - 10) + 'px';
            textInput.style.zIndex = '1002';
            
            textInput.style.fontSize = fontSize + 'px';
            textInput.style.color = currentColor;
            textInput.style.background = 'rgba(255, 255, 255, 0.95)';
            textInput.style.border = '2px solid ' + currentColor;
            textInput.style.borderRadius = '4px';
            textInput.style.outline = 'none';
            textInput.style.fontFamily = 'Arial, sans-serif';
            textInput.style.padding = '6px 8px';
            textInput.style.minWidth = '100px';
            textInput.style.minHeight = (fontSize + 12) + 'px';
            textInput.style.resize = 'both';
            textInput.style.overflow = 'hidden';
            textInput.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
            textInput.style.lineHeight = '1.2';
            textInput.style.display = 'block';
            textInput.placeholder = 'Type text...';
            textInput.setAttribute('data-text-input', 'true');
            
            document.body.appendChild(textInput);
            
            // Store the position for later
            activeTextBox = {
                x: x,
                y: y,
                text: '',
                color: currentColor,
                fontSize: fontSize,
                fontFamily: fontFamily,
                bold: textBold,
                italic: textItalic
            };

            // Apply current formatting to the input
            updateTextStyle(textInput, activeTextBox);
            textInput.style.fontFamily = fontFamily;
            
            // Focus and select
            textInput.focus();
            
            // Auto-resize function
            function autoResize() {
                textInput.style.height = 'auto';
                textInput.style.height = Math.max(fontSize + 12, textInput.scrollHeight) + 'px';
                textInput.style.width = 'auto';
                const minWidth = 100;
                const maxWidth = canvas.width - x - 20;
                const textWidth = Math.min(Math.max(minWidth, textInput.scrollWidth + 10), maxWidth);
                textInput.style.width = textWidth + 'px';
            }
            
            // Add input event for auto-resizing
            textInput.addEventListener('input', autoResize);
            
            // Handle keyboard events
            textInput.addEventListener('keydown', function(e) {
                e.stopPropagation();
                
                // Ctrl+Enter or Alt+Enter to finish
                if ((e.ctrlKey || e.altKey) && e.key === 'Enter') {
                    e.preventDefault();
                    finalizeTextInput();
                }
                // Escape to cancel
                else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelTextInput();
                }
                // Allow normal Enter for new lines
                else if (e.key === 'Enter') {
                    setTimeout(autoResize, 10);
                }
            });
            
            textInput.addEventListener('keyup', autoResize);
            
            // Prevent canvas events when interacting with textarea
            textInput.addEventListener('mousedown', function(e) {
                e.stopPropagation();
            });
            
            textInput.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            // Initial auto-resize
            setTimeout(autoResize, 10);
        }
        
        function editExistingText(textBox) {
            saveState();
            
            // Remove the text from canvas first
            const index = textBoxes.indexOf(textBox);
            if (index > -1) {
                textBoxes.splice(index, 1);
                redrawCanvas();
            }
            
            // Inherit formatting from the existing text
            fontSize = textBox.fontSize || fontSize;
            fontFamily = textBox.fontFamily || fontFamily;
            textBold = textBox.bold || false;
            textItalic = textBox.italic || false;
            currentColor = textBox.color || currentColor;
            
            // Update UI controls to reflect the inherited formatting
            document.getElementById('fontSizeSlider').value = fontSize;
            document.getElementById('fontFamily').value = fontFamily;
            document.getElementById('boldButton').classList.toggle('active', textBold);
            document.getElementById('italicButton').classList.toggle('active', textItalic);
            
            // Create textarea with existing text
            textInput = document.createElement('textarea');
            textInput.style.position = 'absolute';
            
            // Convert world coordinates to screen coordinates for positioning
            const screenPos = worldToScreen(textBox.x, textBox.y);
            textInput.style.left = (canvas.getBoundingClientRect().left + window.scrollX + screenPos.x) + 'px';
            textInput.style.top = (canvas.getBoundingClientRect().top + window.scrollY + screenPos.y - (textBox.fontSize || fontSize) - 10) + 'px';
            textInput.style.zIndex = '1002';
            
            textInput.value = textBox.text;
            textInput.style.fontSize = fontSize + 'px';
            textInput.style.fontFamily = fontFamily;
            textInput.style.fontWeight = textBold ? 'bold' : 'normal';
            textInput.style.fontStyle = textItalic ? 'italic' : 'normal';
            textInput.style.color = currentColor;
            textInput.style.background = 'rgba(255, 255, 255, 0.95)';
            textInput.style.border = '2px solid ' + currentColor;
            textInput.style.borderRadius = '4px';
            textInput.style.outline = 'none';
            textInput.style.fontFamily = 'Arial, sans-serif';
            textInput.style.padding = '6px 8px';
            textInput.style.minWidth = '100px';
            textInput.style.minHeight = (fontSize + 12) + 'px';
            textInput.style.resize = 'both';
            textInput.style.overflow = 'hidden';
            textInput.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
            textInput.style.lineHeight = '1.2';
            textInput.style.display = 'block';
            textInput.placeholder = 'Type text...';
            textInput.setAttribute('data-text-input', 'true');
            
            document.body.appendChild(textInput);
            
            activeTextBox = {
                x: textBox.x,
                y: textBox.y,
                text: textBox.text,
                color: textBox.color,
                fontSize: textBox.fontSize
            };
            
            textInput.focus();
            textInput.select();
            
            // Auto-resize function
            function autoResize() {
                textInput.style.height = 'auto';
                textInput.style.height = Math.max(textBox.fontSize + 12, textInput.scrollHeight) + 'px';
                textInput.style.width = 'auto';
                const minWidth = 100;
                const maxWidth = canvas.width - textBox.x - 20;
                const textWidth = Math.min(Math.max(minWidth, textInput.scrollWidth + 10), maxWidth);
                textInput.style.width = textWidth + 'px';
            }
            
            textInput.addEventListener('input', autoResize);
            
            textInput.addEventListener('keydown', function(e) {
                e.stopPropagation();
                if ((e.ctrlKey || e.altKey) && e.key === 'Enter') {
                    e.preventDefault();
                    finalizeTextInput();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelTextInput();
                } else if (e.key === 'Enter') {
                    setTimeout(autoResize, 10);
                }
            });
            
            textInput.addEventListener('keyup', autoResize);
            
            textInput.addEventListener('mousedown', function(e) {
                e.stopPropagation();
            });
            
            textInput.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            setTimeout(autoResize, 10);
        }
        
        // Text formatting helper functions
        window.updateTextFontSize = function(size) {
            fontSize = parseInt(size);
            document.getElementById('textFontSize').textContent = size + 'px';
            if (textInput) {
                textInput.style.fontSize = fontSize + 'px';
                if (activeTextBox) {
                    activeTextBox.fontSize = fontSize;
                }
                // Trigger resize
                setTimeout(() => {
                    if (textInput) {
                        const event = new Event('input');
                        textInput.dispatchEvent(event);
                    }
                }, 10);
            }
        };
        
        window.applyTextFormat = function(format) {
            if (!textInput || !activeTextBox) return;
            
            if (format === 'bold') {
                const isBold = textInput.style.fontWeight === 'bold';
                textInput.style.fontWeight = isBold ? 'normal' : 'bold';
                activeTextBox.fontWeight = isBold ? 'normal' : 'bold';
            } else if (format === 'italic') {
                const isItalic = textInput.style.fontStyle === 'italic';
                textInput.style.fontStyle = isItalic ? 'normal' : 'italic';
                activeTextBox.fontStyle = isItalic ? 'normal' : 'italic';
            }
        };

        function finalizeTextInput() {
            if (!textInput || !activeTextBox) return;
            
            const text = textInput.value.trim();
            
            if (text) {
                activeTextBox.text = text;
                textBoxes.push(activeTextBox);
                drawText(activeTextBox);
                
                // Mark as modified
                const currentWb = getCurrentWhiteboard();
                if (currentWb) {
                    currentWb.modified = true;
                    renderWhiteboardTabs();
                }
            }
            
            // Clean up
            if (textInput && textInput.parentNode) {
                document.body.removeChild(textInput);
            }
            textInput = null;
            activeTextBox = null;
        }
        
        function cancelTextInput() {
            // Clean up
            if (textInput && textInput.parentNode) {
                document.body.removeChild(textInput);
            }
            textInput = null;
            activeTextBox = null;
        }
        
        function drawText(textBox) {
            ctx.save();
            
            // Apply text formatting
            let fontString = '';
            if (textBox.bold) fontString += 'bold ';
            if (textBox.italic) fontString += 'italic ';
            fontString += (textBox.fontSize || fontSize) + 'px ' + (textBox.fontFamily || 'Arial') + ', sans-serif';
            
            ctx.font = fontString;
            ctx.fillStyle = textBox.color;
            ctx.textBaseline = 'top';
            
            // Handle multiline text
            const lines = textBox.text.split('\n');
            const lineHeight = (textBox.fontSize || fontSize) * 1.2;
            
            lines.forEach((line, index) => {
                const yPos = textBox.y - (textBox.fontSize || fontSize) + (index * lineHeight);
                ctx.fillText(line, textBox.x, yPos);
            });
            
            ctx.restore();
        }
        
        function redrawCanvas() {
            // Don't redraw if currently drawing with pen/eraser to avoid interrupting strokes
            if (isDrawing && (currentTool === 'pen' || currentTool === 'eraser')) {
                return;
            }
            
            // Clear the entire canvas
            resetTransform();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // First, restore the base drawing layer (pen/eraser strokes only)
            if (drawingHistory.length > 0 && historyStep >= 0) {
                const currentState = drawingHistory[historyStep];
                if (currentState && currentState.imageData) {
                    // Draw imageData at screen position (no transform needed for imageData)
                    resetTransform();
                    ctx.putImageData(currentState.imageData, 0, 0);
                }
            }
            
            // Apply viewport transformation for shapes and text
            applyTransform();
            
            // Then draw all shapes on top of the base layer
            shapes.forEach(shape => {
                drawShape(shape);
            });
            
            // Then draw all text boxes
            textBoxes.forEach(textBox => {
                drawText(textBox);
            });
            
            // Reset transform for UI elements like selection
            resetTransform();
            
            // Draw selection highlight last (in screen coordinates)
            if (selectedShape) {
                drawSelection(selectedShape);
            }
        }

        function saveState() {
            if (isRestoring) return;
            
            historyStep++;
            
            // Remove any future history if we're not at the end
            if (historyStep < drawingHistory.length) {
                drawingHistory.length = historyStep;
            }
            
            // Clear canvas and redraw only pen/eraser strokes (not shapes) to capture base layer
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // If there's previous history, restore the base drawing layer only
            if (drawingHistory.length > 0 && historyStep > 0) {
                const prevState = drawingHistory[historyStep - 1];
                if (prevState && prevState.imageData) {
                    tempCtx.putImageData(prevState.imageData, 0, 0);
                }
            }
            
            // Save current state with separated data
            drawingHistory[historyStep] = {
                imageData: tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height),
                textBoxes: JSON.parse(JSON.stringify(textBoxes)),
                shapes: JSON.parse(JSON.stringify(shapes))
            };
            
            // Limit history size
            if (drawingHistory.length > 20) {
                drawingHistory.shift();
                historyStep--;
            }
        }

        function undoDrawing() {
            if (historyStep > 0) {
                historyStep--;
                restoreState(drawingHistory[historyStep]);
            }
        }

        function redoDrawing() {
            if (historyStep < drawingHistory.length - 1) {
                historyStep++;
                restoreState(drawingHistory[historyStep]);
            }
        }
        
        function restoreState(state) {
            if (!state) return;
            
            isRestoring = true;
            
            // Clear canvas completely
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Restore canvas content
            if (state.imageData) {
                ctx.putImageData(state.imageData, 0, 0);
            }
            
            // Restore text boxes from the saved state
            if (state.textBoxes) {
                textBoxes = JSON.parse(JSON.stringify(state.textBoxes));
            }
            
            // Restore shapes from the saved state
            if (state.shapes) {
                shapes = JSON.parse(JSON.stringify(state.shapes));
            }
            
            // Clear selection when restoring
            selectedShape = null;
            
            isRestoring = false;
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            textBoxes = []; // Clear all text boxes
            shapes = []; // Clear all shapes
            saveState();
            
            // Mark current whiteboard as modified
            const currentWb = getCurrentWhiteboard();
            if (currentWb) {
                currentWb.modified = true;
                renderWhiteboardTabs();
            }
        }

        function saveWhiteboard() {
            const currentWb = getCurrentWhiteboard();
            if (!currentWb) return;
            
            const dataURL = canvas.toDataURL();
            const link = document.createElement('a');
            link.download = currentWb.name;
            link.href = dataURL;
            link.click();
            
            // Mark as saved (not modified)
            currentWb.modified = false;
            renderWhiteboardTabs();
        }

        function loadWhiteboard() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.onload = function() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(img, 0, 0);
                            
                            // Update current whiteboard name and mark as modified
                            const currentWb = getCurrentWhiteboard();
                            if (currentWb) {
                                currentWb.name = file.name.replace(/\.[^/.]+$/, '') + '.png';
                                currentWb.modified = true;
                                currentWb.data = canvas.toDataURL();
                                renderWhiteboardTabs();
                            }
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }

        function toggleTheme() {
            const body = document.body;
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            body.setAttribute('data-theme', newTheme);
            
            // Update theme status display (if we had one)
            localStorage.setItem('whiteboardTheme', newTheme);
        }

        function updateCanvasSize() {
            const canvasSizeDisplay = document.getElementById('canvasSize');
            const zoomElement = document.getElementById('zoomDisplay');
            if (canvasSizeDisplay) {
                canvasSizeDisplay.textContent = `${canvas.width} x ${canvas.height}`;
            }
            if (zoomElement) {
                zoomElement.textContent = `${Math.round(zoomLevel * 100)}%`;
            }
        }

        // Initialize application
        function initializeApp() {
            // Load saved theme
            const savedTheme = localStorage.getItem('whiteboardTheme') || 'dark';
            document.body.setAttribute('data-theme', savedTheme);
            
            // Initialize canvas
            initCanvas();
            
            // Render initial tabs
            renderWhiteboardTabs();
            
            // Add keyboard shortcuts
            document.addEventListener('keydown', handleKeyboardShortcuts);
        }

        // Handle keyboard shortcuts
        function handleKeyboardShortcuts(e) {
            // Don't handle shortcuts if we're typing in a text input
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
                return;
            }
            
            const ctrlKey = e.ctrlKey || e.metaKey;
            
            if (ctrlKey) {
                switch(e.key.toLowerCase()) {
                    case 'z':
                        if (e.shiftKey) {
                            // Ctrl+Shift+Z = Redo
                            e.preventDefault();
                            e.stopPropagation();
                            redoDrawing();
                        } else {
                            // Ctrl+Z = Undo
                            e.preventDefault();
                            e.stopPropagation();
                            undoDrawing();
                        }
                        break;
                    case 'y':
                        // Ctrl+Y = Redo
                        e.preventDefault();
                        e.stopPropagation();
                        redoDrawing();
                        break;
                    case 's':
                        // Ctrl+S = Save whiteboard
                        e.preventDefault();
                        e.stopPropagation();
                        saveWhiteboard();
                        break;
                    case 'n':
                        // Ctrl+N = New whiteboard
                        e.preventDefault();
                        e.stopPropagation();
                        newWhiteboard();
                        break;
                    case 'o':
                        // Ctrl+O = Open/Load whiteboard
                        e.preventDefault();
                        e.stopPropagation();
                        loadWhiteboard();
                        break;
                    case 'c':
                        // Ctrl+C = Copy shape
                        if (selectedShape) {
                            e.preventDefault();
                            e.stopPropagation();
                            copyShape();
                        }
                        break;
                    case 'x':
                        // Ctrl+X = Cut shape
                        if (selectedShape) {
                            e.preventDefault();
                            e.stopPropagation();
                            cutShape();
                        }
                        break;
                    case 'v':
                        // Ctrl+V = Paste shape
                        e.preventDefault();
                        e.stopPropagation();
                        if (copiedShape) {
                            pasteShape();
                        }
                        break;
                }
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                // Delete selected shape
                if (selectedShape) {
                    e.preventDefault();
                    e.stopPropagation();
                    deleteShape();
                }
            } else if (e.key === 'Escape') {
                // Clear selection
                if (selectedShape) {
                    e.preventDefault();
                    e.stopPropagation();
                    selectedShape = null;
                    redrawCanvas();
                }
            }
        }
        
        // Shape manipulation functions
        function findShapeAt(x, y) {
            for (let i = shapes.length - 1; i >= 0; i--) {
                const shape = shapes[i];
                
                if (shape.type === 'line' || shape.type === 'arrow' || shape.type === 'double-arrow') {
                    // For lines/arrows, create a bounding box with larger padding for easier selection
                    const minX = Math.min(shape.x, shape.width) - 25;
                    const maxX = Math.max(shape.x, shape.width) + 25;
                    const minY = Math.min(shape.y, shape.height) - 25;
                    const maxY = Math.max(shape.y, shape.height) + 25;
                    
                    // First check if point is in expanded bounding box
                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                        // Then check distance to actual line with more generous tolerance
                        const distance = distanceFromPointToLine(x, y, shape.x, shape.y, shape.width, shape.height);
                        if (distance < 25) { // 25px tolerance for easier selection
                            return shape;
                        }
                    }
                } else {
                    // For rectangles and circles, use bounding box with small padding
                    if (x >= shape.x - 5 && x <= shape.x + shape.width + 5 &&
                        y >= shape.y - 5 && y <= shape.y + shape.height + 5) {
                        return shape;
                    }
                }
            }
            return null;
        }
        
        // Helper function to calculate distance from point to line
        function distanceFromPointToLine(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) {
                param = dot / lenSq;
            }
            
            let xx, yy;
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function getResizeHandle(x, y, shape) {
            const handleSize = 8;
            let selectionX, selectionY, selectionWidth, selectionHeight;
            
            // Calculate proper selection bounds
            if (shape.type === 'line' || shape.type === 'arrow' || shape.type === 'double-arrow') {
                const startX = shape.x;
                const startY = shape.y;
                const endX = shape.width;
                const endY = shape.height;
                
                selectionX = Math.min(startX, endX) - 10;
                selectionY = Math.min(startY, endY) - 10;
                selectionWidth = Math.abs(endX - startX) + 20;
                selectionHeight = Math.abs(endY - startY) + 20;
                
                if (selectionWidth < 40) {
                    selectionX -= (40 - selectionWidth) / 2;
                    selectionWidth = 40;
                }
                if (selectionHeight < 40) {
                    selectionY -= (40 - selectionHeight) / 2;
                    selectionHeight = 40;
                }
            } else {
                selectionX = shape.x - 3;
                selectionY = shape.y - 3;
                selectionWidth = shape.width + 6;
                selectionHeight = shape.height + 6;
            }
            
            // Check rotation handle first (orange circle above shape)
            const rotateX = selectionX + selectionWidth / 2;
            const rotateY = selectionY - 30;
            const rotateDistance = Math.sqrt((x - rotateX) * (x - rotateX) + (y - rotateY) * (y - rotateY));
            if (rotateDistance <= 10) { // 10px radius for rotation handle
                return 'rotate';
            }
            
            const handles = [
                { name: 'nw', x: selectionX, y: selectionY },
                { name: 'ne', x: selectionX + selectionWidth, y: selectionY },
                { name: 'sw', x: selectionX, y: selectionY + selectionHeight },
                { name: 'se', x: selectionX + selectionWidth, y: selectionY + selectionHeight }
            ];
            
            for (let handle of handles) {
                if (x >= handle.x - handleSize/2 && x <= handle.x + handleSize/2 &&
                    y >= handle.y - handleSize/2 && y <= handle.y + handleSize/2) {
                    return handle.name;
                }
            }
            return null;
        }
        
        function resizeShape(shape, mouseX, mouseY, handle) {
            const minSize = 10;
            
            switch(handle) {
                case 'nw':
                    const newWidth = shape.x + shape.width - mouseX;
                    const newHeight = shape.y + shape.height - mouseY;
                    if (newWidth > minSize && newHeight > minSize) {
                        shape.width = newWidth;
                        shape.height = newHeight;
                        shape.x = mouseX;
                        shape.y = mouseY;
                    }
                    break;
                case 'ne':
                    const newWidth2 = mouseX - shape.x;
                    const newHeight2 = shape.y + shape.height - mouseY;
                    if (newWidth2 > minSize && newHeight2 > minSize) {
                        shape.width = newWidth2;
                        shape.height = newHeight2;
                        shape.y = mouseY;
                    }
                    break;
                case 'sw':
                    const newWidth3 = shape.x + shape.width - mouseX;
                    const newHeight3 = mouseY - shape.y;
                    if (newWidth3 > minSize && newHeight3 > minSize) {
                        shape.width = newWidth3;
                        shape.height = newHeight3;
                        shape.x = mouseX;
                    }
                    break;
                case 'se':
                    const newWidth4 = mouseX - shape.x;
                    const newHeight4 = mouseY - shape.y;
                    if (newWidth4 > minSize && newHeight4 > minSize) {
                        shape.width = newWidth4;
                        shape.height = newHeight4;
                    }
                    break;
            }
        }
        
        function drawSelection(shape) {
            ctx.save();
            ctx.strokeStyle = '#007acc';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            // Draw selection border
            let selectionX, selectionY, selectionWidth, selectionHeight;
            
            if (shape.type === 'line' || shape.type === 'arrow' || shape.type === 'double-arrow') {
                // For lines, create a bounding box around the actual line
                const startX = shape.x;
                const startY = shape.y;
                const endX = shape.width;  // width stores end X for lines
                const endY = shape.height; // height stores end Y for lines
                
                selectionX = Math.min(startX, endX) - 10;
                selectionY = Math.min(startY, endY) - 10;
                selectionWidth = Math.abs(endX - startX) + 20;
                selectionHeight = Math.abs(endY - startY) + 20;
                
                // Ensure minimum size for very short lines
                if (selectionWidth < 40) {
                    selectionX -= (40 - selectionWidth) / 2;
                    selectionWidth = 40;
                }
                if (selectionHeight < 40) {
                    selectionY -= (40 - selectionHeight) / 2;
                    selectionHeight = 40;
                }
            } else {
                // For rectangles and circles, use normal bounds
                selectionX = shape.x - 3;
                selectionY = shape.y - 3;
                selectionWidth = shape.width + 6;
                selectionHeight = shape.height + 6;
            }
            
            ctx.strokeRect(selectionX, selectionY, selectionWidth, selectionHeight);
            
            ctx.setLineDash([]);
            ctx.fillStyle = '#007acc';
            const handleSize = 8;
            
            // Draw resize handles
            const handles = [
                { x: selectionX, y: selectionY }, // top-left
                { x: selectionX + selectionWidth/2, y: selectionY }, // top-center
                { x: selectionX + selectionWidth, y: selectionY }, // top-right
                { x: selectionX + selectionWidth, y: selectionY + selectionHeight/2 }, // middle-right
                { x: selectionX + selectionWidth, y: selectionY + selectionHeight }, // bottom-right
                { x: selectionX + selectionWidth/2, y: selectionY + selectionHeight }, // bottom-center
                { x: selectionX, y: selectionY + selectionHeight }, // bottom-left
                { x: selectionX, y: selectionY + selectionHeight/2 } // middle-left
            ];
            
            handles.forEach(handle => {
                ctx.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
                // Add white border to make handles more visible
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.strokeRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
            });
            
            // Draw rotation handle (larger circle above the shape)
            const rotateX = selectionX + selectionWidth / 2;
            const rotateY = selectionY - 30; // Move further up for better visibility
            ctx.fillStyle = '#ff6b35'; // Orange color for rotation
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(rotateX, rotateY, 10, 0, 2 * Math.PI); // Larger handle
            ctx.fill();
            ctx.stroke();
            
            // Add rotation icon inside handle
            ctx.save();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(rotateX, rotateY, 6, 0.2, 1.8 * Math.PI);
            ctx.stroke();
            // Add arrow to rotation icon
            ctx.beginPath();
            ctx.moveTo(rotateX + 4, rotateY - 4);
            ctx.lineTo(rotateX + 6, rotateY - 2);
            ctx.lineTo(rotateX + 4, rotateY);
            ctx.stroke();
            ctx.restore();
            
            // Draw line connecting rotation handle to shape
            ctx.strokeStyle = '#007acc';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.moveTo(rotateX, rotateY + 10);
            ctx.lineTo(selectionX + selectionWidth/2, selectionY);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function copyShape() {
            if (selectedShape) {
                copiedShape = JSON.parse(JSON.stringify(selectedShape));
            }
        }
        
        function cutShape() {
            if (selectedShape) {
                copiedShape = JSON.parse(JSON.stringify(selectedShape));
                deleteShape();
            }
        }
        
        function pasteShape() {
            if (copiedShape) {
                const newShape = JSON.parse(JSON.stringify(copiedShape));
                newShape.x += 20;
                newShape.y += 20;
                newShape.id = Date.now();
                shapes.push(newShape);
                selectedShape = newShape;
                redrawCanvas();
                saveState();
            } else {
                // No copied shape available
            }
        }
        
        function deleteShape() {
            if (selectedShape) {
                const index = shapes.indexOf(selectedShape);
                if (index > -1) {
                    shapes.splice(index, 1);
                    selectedShape = null;
                    redrawCanvas();
                    saveState();
                }
            }
        }
        
        // Shape drawing and management functions
        function drawShape(shape) {
            ctx.save();
            ctx.strokeStyle = shape.color;
            ctx.lineWidth = shape.lineWidth;
            ctx.fillStyle = 'transparent';
            
            // Apply rotation if shape has angle
            if (shape.angle && shape.angle !== 0) {
                let centerX, centerY;
                if (shape.type === 'line' || shape.type === 'arrow' || shape.type === 'double-arrow') {
                    // For line-based shapes, use midpoint of the line
                    centerX = (shape.x + shape.width) / 2;
                    centerY = (shape.y + shape.height) / 2;
                } else {
                    // For rectangles and circles, use geometric center
                    centerX = shape.x + shape.width / 2;
                    centerY = shape.y + shape.height / 2;
                }
                ctx.translate(centerX, centerY);
                ctx.rotate(shape.angle);
                ctx.translate(-centerX, -centerY);
            }

            ctx.beginPath();
            if (shape.type === 'rectangle') {
                ctx.rect(shape.x, shape.y, shape.width, shape.height);
            } else if (shape.type === 'circle') {
                const centerX = shape.x + shape.width / 2;
                const centerY = shape.y + shape.height / 2;
                const radius = Math.min(shape.width, shape.height) / 2;
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            } else if (shape.type === 'line') {
                ctx.moveTo(shape.x, shape.y);
                ctx.lineTo(shape.width, shape.height); // width/height store end coordinates
            } else if (shape.type === 'arrow') {
                drawArrow(ctx, shape.x, shape.y, shape.width, shape.height);
            } else if (shape.type === 'double-arrow') {
                drawDoubleArrow(ctx, shape.x, shape.y, shape.width, shape.height);
            }
            if (shape.type !== 'arrow' && shape.type !== 'double-arrow') {
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawShapePreview(startX, startY, endX, endY) {
            ctx.save();
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentSize;
            ctx.setLineDash([5, 5]);

            const x = Math.min(startX, endX);
            const y = Math.min(startY, endY);
            const width = Math.abs(endX - startX);
            const height = Math.abs(endY - startY);

            ctx.beginPath();
            if (currentTool === 'rectangle') {
                ctx.rect(x, y, width, height);
            } else if (currentTool === 'circle') {
                const centerX = x + width / 2;
                const centerY = y + height / 2;
                const radius = Math.min(width, height) / 2;
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            } else if (currentTool === 'line') {
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
            } else if (currentTool === 'arrow') {
                drawArrow(ctx, startX, startY, endX, endY);
            } else if (currentTool === 'double-arrow') {
                drawDoubleArrow(ctx, startX, startY, endX, endY);
            }
            
            if (currentTool !== 'arrow' && currentTool !== 'double-arrow') {
                ctx.stroke();
            }
            ctx.restore();
        }

        // Arrow drawing functions
        function drawArrow(context, startX, startY, endX, endY) {
            const headLength = 15;
            const angle = Math.atan2(endY - startY, endX - startX);
            context.beginPath();
            context.moveTo(startX, startY);
            context.lineTo(endX, endY);
            context.stroke();
            context.beginPath();
            context.moveTo(endX, endY);
            context.lineTo(endX - headLength * Math.cos(angle - Math.PI / 6), endY - headLength * Math.sin(angle - Math.PI / 6));
            context.moveTo(endX, endY);
            context.lineTo(endX - headLength * Math.cos(angle + Math.PI / 6), endY - headLength * Math.sin(angle + Math.PI / 6));
            context.stroke();
        }
        
        function drawDoubleArrow(context, startX, startY, endX, endY) {
            const headLength = 15;
            const angle = Math.atan2(endY - startY, endX - startX);
            context.beginPath();
            context.moveTo(startX, startY);
            context.lineTo(endX, endY);
            context.stroke();
            context.beginPath();
            context.moveTo(endX, endY);
            context.lineTo(endX - headLength * Math.cos(angle - Math.PI / 6), endY - headLength * Math.sin(angle - Math.PI / 6));
            context.moveTo(endX, endY);
            context.lineTo(endX - headLength * Math.cos(angle + Math.PI / 6), endY - headLength * Math.sin(angle + Math.PI / 6));
            context.moveTo(startX, startY);
            context.lineTo(startX + headLength * Math.cos(angle - Math.PI / 6), startY + headLength * Math.sin(angle - Math.PI / 6));
            context.moveTo(startX, startY);
            context.lineTo(startX + headLength * Math.cos(angle + Math.PI / 6), startY + headLength * Math.sin(angle + Math.PI / 6));
            context.stroke();
        }

        // Initialize canvas when page loads
        window.addEventListener('load', initializeApp);
    </script>
</body>
</html>
