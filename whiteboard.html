<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whiteboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* Text Editor matching styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }
        
        /* Theme Variables - Exact match to Text Editor */
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #2d2d30;
            --text-primary: #d4d4d4;
            --text-secondary: #a0a0a0;
            --border-color: #3c3c3c;
            --accent-color: #61dafb;
            --highlight-bg: #264f78;
        }
        
        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f8f8;
            --bg-tertiary: #e8e8e8;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border-color: #cccccc;
            --accent-color: #0078d4;
            --highlight-bg: #b3d9ff;
        }

        .app {
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-primary);
        }

        /* Header - Exact match to Text Editor */
        .header {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-primary));
            border-bottom: 1px solid var(--border-color);
            padding: 12px 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .menu-bar {
            display: flex;
            gap: 0;
            margin-right: 20px;
        }

        .header h1 {
            color: var(--accent-color);
            font-size: 20px;
            font-weight: 600;
        }

        .menu-item {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            position: relative;
            transition: all 0.2s ease;
        }

        .menu-item:hover {
            background-color: var(--bg-tertiary);
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            min-width: 180px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            display: none;
            z-index: 1000;
        }

        .menu-item:hover .dropdown-menu {
            display: block;
        }

        .dropdown-item {
            padding: 8px 16px;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 13px;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .dropdown-item:hover {
            background-color: var(--bg-tertiary);
        }

        /* Submenu styles for Insert > Shape */
        .dropdown-submenu {
            position: relative;
        }

        .dropdown-submenu-content {
            position: absolute;
            top: 0;
            left: 100%;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            min-width: 120px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            display: none;
            z-index: 1001;
        }

        .dropdown-submenu:hover .dropdown-submenu-content {
            display: block;
        }

        .dropdown-separator {
            height: 1px;
            background-color: var(--border-color);
            margin: 4px 0;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        /* File Tabs - Match Text Editor */
        .file-tabs {
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 5px 10px;
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .file-tab {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px 4px 0 0;
            padding: 8px 16px;
            margin-right: 2px;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 13px;
            position: relative;
        }

        .file-tab.active {
            background: var(--bg-primary);
            border-bottom-color: var(--bg-primary);
        }

        .file-tab:hover {
            background: var(--bg-tertiary);
        }

        .file-tab-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-tab-close {
            margin-left: 8px;
            cursor: pointer;
            opacity: 0.7;
        }

        .file-tab-close:hover {
            opacity: 1;
            color: var(--accent-color);
        }

        .new-file-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
        }

        .new-file-btn:hover {
            background: var(--accent-color);
        }

        /* Toolbar - Match Text Editor */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 8px;
            background-color: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .tool-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Buttons - Match Text Editor style */
        button {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button:hover {
            background: var(--accent-color);
            color: white;
        }

        .tool-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            min-width: 60px;
            transition: all 0.2s ease;
            font-size: 11px;
        }

        .tool-btn.active {
            background: var(--accent-color);
            color: white;
        }

        .tool-btn:hover {
            background: var(--accent-color);
            color: white;
        }

        .format-btn {
            background: var(--button-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 0 2px;
            min-width: 32px;
            height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        .format-btn:hover {
            background: var(--accent-color);
            color: white;
        }

        .format-btn.active {
            background: var(--accent-color);
            color: white;
        }

        #fontFamily {
            background: var(--button-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 14px;
            margin: 0 4px;
            min-width: 100px;
        }

        #fontFamily:focus {
            outline: 2px solid var(--accent-color);
            outline-offset: -2px;
        }

        .tool-separator {
            width: 1px;
            height: 30px;
            background: var(--border-color);
            margin: 0 10px;
        }

        .color-palette {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .color-btn {
            width: 28px;
            height: 28px;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .color-btn.active {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 1px var(--accent-color);
        }

        .color-btn:hover {
            border-color: var(--accent-color);
        }

        .shape-btn {
            width: 32px;
            height: 32px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--bg-tertiary);
            color: var(--text-color);
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 2px;
        }

        .shape-btn.active {
            border-color: var(--accent-color);
            background: var(--accent-color);
            color: white;
            box-shadow: 0 0 0 1px var(--accent-color);
        }

        .shape-btn:hover {
            border-color: var(--accent-color);
            background: var(--bg-secondary);
        }

        .shape-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
        }

        .color-picker {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            background: none;
        }

        /* Drawing Canvas Container */
        .drawing-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        #drawingCanvas {
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            cursor: crosshair;
        }

        /* Status Bar - Match Text Editor */
        .status-bar {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 5px 10px;
            display: flex;
            gap: 20px;
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 10px;
        }

        /* Range input styling */
        input[type="range"] {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            height: 20px;
        }

        /* Label styling */
        label {
            color: var(--text-primary);
            font-size: 13px;
        }

        /* Span styling for size display */
        #sizeDisplay, #currentTool, #currentSizeDisplay {
            color: var(--accent-color);
            font-weight: 500;
        }
    </style>
</head>
<body data-theme="dark">
    <div class="app">
        <!-- Header -->
        <div class="header">
            <div class="menu-bar">
        <div class="menu-item">
            File
            <div class="dropdown-menu">
                <button class="dropdown-item" onclick="clearCanvas()">New</button>
                <button class="dropdown-item" onclick="loadWhiteboard()">Open</button>
                <button class="dropdown-item" onclick="saveWhiteboard()">Save</button>
            </div>
        </div>
        <div class="menu-item">
            Edit
            <div class="dropdown-menu">
                <button class="dropdown-item" onclick="undoDrawing()">Undo</button>
                <button class="dropdown-item" onclick="redoDrawing()">Redo</button>
                <button class="dropdown-item" onclick="clearCanvas()">Clear All</button>
            </div>
        </div>
        <div class="menu-item">
            View
            <div class="dropdown-menu">
                <button class="dropdown-item" onclick="toggleTheme()">Toggle Theme</button>
            </div>
        </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- File Tabs -->
            <div class="file-tabs" id="fileTabs">
                <button class="new-file-btn" onclick="newWhiteboard()">+</button>
            </div>

            <!-- Drawing Tools Toolbar -->
            <div class="toolbar">
                <div class="tool-group">
                    <button id="textTool" class="tool-btn active" onclick="setDrawingTool('text')">
                        <span>Aa</span>Text
                    </button>
                    <button id="shapeTool" class="tool-btn" onclick="setDrawingTool('shape')">
                        <span>‚ñ°</span>Shape
                    </button>
                </div>
                
                <div class="tool-separator"></div>
                

                

                
                <!-- Text Tool Controls -->
                <div id="textControls" class="tool-group" style="display: none;">
                    <select id="fontFamily" onchange="setFontFamily(this.value)">
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                    </select>
                </div>
                
                <div id="textSeparator1" class="tool-separator" style="display: none;"></div>
                
                <div id="textSizeControls" class="tool-group" style="display: none;">
                    <input type="range" id="fontSizeSlider" min="10" max="72" value="16" onchange="setFontSize(this.value)">
                    <span id="fontSizeDisplay">16px</span>
                </div>
                
                <div id="textSeparator2" class="tool-separator" style="display: none;"></div>
                
                <div id="textFormatControls" class="tool-group" style="display: none;">
                    <button id="boldButton" class="format-btn" onclick="toggleTextFormat('bold')" onmousedown="event.preventDefault()" title="Bold">
                        <strong>B</strong>
                    </button>
                    <button id="italicButton" class="format-btn" onclick="toggleTextFormat('italic')" onmousedown="event.preventDefault()" title="Italic">
                        <em>I</em>
                    </button>
                </div>
                
                <div id="textSeparator3" class="tool-separator" style="display: none;"></div>
                
                <div id="textColorControls" class="tool-group" style="display: none;">
                    <div class="color-palette">
                        <button class="color-btn text-color-btn active" style="background: #ff0000;" onclick="setDrawingColor('#ff0000')" title="Red"></button>
                        <button class="color-btn text-color-btn" style="background: #0000ff;" onclick="setDrawingColor('#0000ff')" title="Blue"></button>
                        <button class="color-btn text-color-btn" style="background: #00ff00;" onclick="setDrawingColor('#00ff00')" title="Green"></button>
                        <input type="color" class="color-picker" onchange="selectCustomColor(this)" title="Custom Color">
                    </div>
                </div>
                
                <!-- Shape Tool Controls -->
                <div id="shapeControls" class="tool-group" style="display: none;">
                    <div class="shape-palette">
                        <button class="shape-btn active" onclick="setShapeType('move')" title="Move/Pan Tool" data-shape="move">üëÜ</button>
                        <button class="shape-btn" onclick="setShapeType('freehand')" title="Freehand Drawing" data-shape="freehand">‚úèÔ∏è</button>
                        <button class="shape-btn" onclick="setShapeType('rectangle')" title="Rectangle" data-shape="rectangle">‚ñ°</button>
                        <button class="shape-btn" onclick="setShapeType('oval')" title="Oval" data-shape="oval">‚óã</button>
                        <button class="shape-btn" onclick="setShapeType('kite')" title="Kite" data-shape="kite">‚óá</button>
                        <button class="shape-btn" onclick="setShapeType('cylinder')" title="Cylinder" data-shape="cylinder">üõ¢</button>
                        <button class="shape-btn" onclick="setShapeType('line')" title="Line" data-shape="line">‚îÄ</button>
                        <button class="shape-btn" onclick="setShapeType('arrow')" title="Arrow" data-shape="arrow">‚Üí</button>
                        <button class="shape-btn" onclick="setShapeType('double-arrow')" title="Double Arrow" data-shape="double-arrow">‚Üî</button>
                    </div>
                </div>
                
                <div id="shapeSeparator1" class="tool-separator" style="display: none;"></div>
                
                <div id="shapeSizeControls" class="tool-group" style="display: none;">
                    <input type="range" id="shapeSize" min="1" max="20" value="3" onchange="setShapeSize(this.value)">
                    <span id="shapeSizeDisplay">3px</span>
                </div>
                
                <div id="shapeSeparator2" class="tool-separator" style="display: none;"></div>
                
                <div id="shapeColorControls" class="tool-group" style="display: none;">
                    <div class="color-palette">
                        <button class="color-btn shape-color-btn active" style="background: #ff0000;" onclick="setDrawingColor('#ff0000')" title="Red"></button>
                        <button class="color-btn shape-color-btn" style="background: #0000ff;" onclick="setDrawingColor('#0000ff')" title="Blue"></button>
                        <button class="color-btn shape-color-btn" style="background: #00ff00;" onclick="setDrawingColor('#00ff00')" title="Green"></button>
                        <input type="color" class="color-picker" onchange="selectCustomColor(this)" title="Custom Color">
                    </div>
                </div>
            </div>

            <!-- Drawing Canvas -->
            <div class="drawing-container">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <!-- Status Bar -->
            <div class="status-bar">
                <span>Mode: Whiteboard</span>
                <span>Tool: <span id="currentTool">Text</span></span>
                <span>Size: <span id="currentSizeDisplay">3px</span></span>
                <span>Canvas: <span id="canvasSize">Loading...</span></span>
                <span>Zoom: <span id="zoomDisplay">100%</span></span>
                <span>Pan: Ctrl+Wheel or Ctrl+Shift+Drag</span>
            </div>
        </div>
    </div>

    <script>
        // Drawing functionality
        let canvas, ctx;
        let currentTool = 'text'; // Default to text tool
        let currentColor = '#ff0000';
        let currentSize = 3;
        
        // Undo/Redo state management
        let drawingHistory = [];
        let historyStep = -1;
        let isRestoring = false;
        
        // Text tool specific variables
        let textBoxes = [];
        let activeTextBox = null;
        let textInput = null;
        let fontSize = 16; // Initialize with default value
        
        // Shape tool variables
        let currentShapeType = 'move';
        let shapes = [];
        let isDrawingShape = false;
        let isDrawingFreehand = false;
        let freehandPath = [];
        let startX, startY;
        let copiedShape = null;
        
        // Shape manipulation variables
        let selectedShape = null;
        let selectedTextBox = null;
        let isDragging = false;
        let isDraggingText = false;
        let isResizing = false;
        let resizeHandle = null;
        let dragOffsetX = 0, dragOffsetY = 0;
        
        // Viewport variables for infinite scroll
        let viewportX = 0;
        let viewportY = 0;
        let zoomLevel = 1;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let lastPanX = 0;
        let lastPanY = 0;
        
        // File management
        let whiteboards = [{
            id: 'whiteboard_0',
            name: 'Untitled.png',
            data: null,
            modified: false
        }];
        let activeWhiteboardId = 'whiteboard_0';
        let whiteboardCounter = 1;
        
        function getCurrentWhiteboard() {
            return whiteboards.find(wb => wb.id === activeWhiteboardId);
        }
        
        function newWhiteboard() {
            const newId = 'whiteboard_' + whiteboardCounter++;
            const newWhiteboard = {
                id: newId,
                name: `Untitled${whiteboardCounter - 1}.png`,
                data: null,
                modified: false
            };
            whiteboards.push(newWhiteboard);
            switchToWhiteboard(newId);
            renderWhiteboardTabs();
        }
        
        function switchToWhiteboard(whiteboardId) {
            // Save current whiteboard state including objects
            if (canvas) {
                const currentWb = getCurrentWhiteboard();
                if (currentWb) {
                    currentWb.data = {
                        imageData: canvas.toDataURL(),
                        shapes: JSON.parse(JSON.stringify(shapes)),
                        textBoxes: JSON.parse(JSON.stringify(textBoxes))
                    };
                }
            }
            
            activeWhiteboardId = whiteboardId;
            renderWhiteboardTabs();
            
            // Load the switched whiteboard
            const targetWb = getCurrentWhiteboard();
            if (targetWb && targetWb.data && canvas) {
                // Restore objects first
                if (targetWb.data.shapes) {
                    shapes.length = 0;
                    shapes.push(...targetWb.data.shapes);
                }
                if (targetWb.data.textBoxes) {
                    textBoxes.length = 0;
                    textBoxes.push(...targetWb.data.textBoxes);
                }
                
                // Clear and redraw canvas with objects
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                redrawCanvas();
            } else if (canvas) {
                // Clear everything for new whiteboard
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                shapes.length = 0;
                textBoxes.length = 0;
            }
        }
        
        function closeWhiteboard(whiteboardId) {
            if (whiteboards.length <= 1) return; // Keep at least one whiteboard
            
            const index = whiteboards.findIndex(wb => wb.id === whiteboardId);
            if (index !== -1) {
                whiteboards.splice(index, 1);
                
                // If closing active whiteboard, switch to another
                if (activeWhiteboardId === whiteboardId) {
                    const newActiveIndex = Math.min(index, whiteboards.length - 1);
                    switchToWhiteboard(whiteboards[newActiveIndex].id);
                } else {
                    renderWhiteboardTabs();
                }
            }
        }
        
        function renderWhiteboardTabs() {
            const tabsContainer = document.getElementById('fileTabs');
            const newFileBtn = tabsContainer.querySelector('.new-file-btn');
            
            // Clear existing tabs but keep new file button
            tabsContainer.innerHTML = '';
            tabsContainer.appendChild(newFileBtn);
            
            // Add tabs for each whiteboard
            whiteboards.forEach(wb => {
                const tab = document.createElement('div');
                tab.className = `file-tab ${wb.id === activeWhiteboardId ? 'active' : ''}`;
                tab.onclick = (e) => {
                    if (!e.target.classList.contains('file-tab-close')) {
                        switchToWhiteboard(wb.id);
                    }
                };
                
                tab.innerHTML = `
                    <span class="file-tab-name">${wb.name}${wb.modified ? ' ‚Ä¢' : ''}</span>
                    ${whiteboards.length > 1 ? `<span class="file-tab-close" onclick="event.stopPropagation(); closeWhiteboard('${wb.id}');">√ó</span>` : ''}
                `;
                
                tabsContainer.appendChild(tab);
            });
        }

        function ensureObjectIds() {
            // Ensure all shapes have IDs
            shapes.forEach(shape => {
                if (!shape.id) {
                    shape.id = Date.now() + Math.random();
                }
            });
            
            // Ensure all text boxes have IDs
            textBoxes.forEach(textBox => {
                if (!textBox.id) {
                    textBox.id = Date.now() + Math.random();
                }
            });
        }

        function initCanvas() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = currentSize;
            ctx.strokeStyle = currentColor;
            ctx.globalCompositeOperation = 'source-over';
            
            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            // Add mouse move for cursor changes
            canvas.addEventListener('mousemove', updateCursor);
            
            // Add wheel event for zoom and pan
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            
            // Touch events
            canvas.addEventListener('touchstart', startDrawing);
            canvas.addEventListener('touchmove', draw);
            canvas.addEventListener('touchend', stopDrawing);
            
            // Only finalize text when clicking outside the input area
            document.addEventListener('mousedown', function(e) {
                if (currentTool === 'text' && activeTextBox && textInput) {
                    // Only finalize if clicking completely outside the text input
                    if (e.target !== textInput && 
                        e.target.getAttribute('data-text-input') !== 'true' &&
                        !textInput.contains(e.target)) {
                        finalizeTextInput();
                    }
                }
            });
            
            // Ensure all objects have IDs and save initial state
            ensureObjectIds();
            saveState();
            
            // Add keyboard shortcuts
            document.addEventListener('keydown', handleKeyboardShortcuts);
            
            function handleKeyboardShortcuts(e) {
                // Delete key - delete selected shape or text
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (selectedShape) {
                        // Remove selected shape
                        const shapeIndex = shapes.findIndex(s => s.id === selectedShape.id);
                        if (shapeIndex !== -1) {
                            shapes.splice(shapeIndex, 1);
                            selectedShape = null;
                            redrawCanvas();
                            saveState();
                        }
                    } else if (selectedTextBox) {
                        // Ensure text box has an ID for proper deletion
                        if (!selectedTextBox.id) {
                            selectedTextBox.id = Date.now();
                        }
                        
                        // Remove selected text box
                        const textIndex = textBoxes.findIndex(t => t.id === selectedTextBox.id);
                        if (textIndex !== -1) {
                            textBoxes.splice(textIndex, 1);
                            selectedTextBox = null;
                            redrawCanvas();
                            saveState();
                        }
                    }
                }
                
                // Ctrl+Z for undo
                if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undoDrawing();
                }
                
                // Ctrl+Shift+Z or Ctrl+Y for redo
                if ((e.ctrlKey && e.shiftKey && e.key === 'Z') || (e.ctrlKey && e.key === 'y')) {
                    e.preventDefault();
                    redoDrawing();
                }
            }
            
            // Add double-click for text editing
            canvas.addEventListener('dblclick', function(e) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const screenX = (e.clientX || e.touches[0].clientX) - rect.left;
                const screenY = (e.clientY || e.touches[0].clientY) - rect.top;
                const worldPos = screenToWorld(screenX, screenY);
                const x = worldPos.x;
                const y = worldPos.y;
                
                if (currentTool === 'text' && selectedTextBox) {
                    editExistingText(selectedTextBox);
                    selectedTextBox = null;
                    redrawCanvas();
                } else {
                    // Check if double-clicking on a shape (only 2D shapes support text)
                    const clickedShape = findShapeAt(x, y);
                    if (clickedShape && (clickedShape.type === 'rectangle' || clickedShape.type === 'oval' || clickedShape.type === 'kite' || clickedShape.type === 'cylinder')) {
                        editShapeText(clickedShape);
                    }
                }
            });
            
            // Add global click handler to clear selection when clicking outside
            document.addEventListener('click', handleGlobalClick);
        }
        
        // Coordinate transformation functions
        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX / zoomLevel) + viewportX,
                y: (screenY / zoomLevel) + viewportY
            };
        }
        
        function worldToScreen(worldX, worldY) {
            return {
                x: (worldX - viewportX) * zoomLevel,
                y: (worldY - viewportY) * zoomLevel
            };
        }
        
        function applyTransform() {
            ctx.setTransform(zoomLevel, 0, 0, zoomLevel, -viewportX * zoomLevel, -viewportY * zoomLevel);
        }
        
        function resetTransform() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
        
        function handleWheel(e) {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Convert to world coordinates before zoom
            const worldPos = screenToWorld(mouseX, mouseY);
            
            if (e.ctrlKey) {
                // Zoom
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                zoomLevel *= zoomFactor;
                zoomLevel = Math.max(0.1, Math.min(5, zoomLevel)); // Limit zoom
                
                // Adjust viewport to zoom towards mouse position
                const newScreenPos = worldToScreen(worldPos.x, worldPos.y);
                viewportX += (mouseX - newScreenPos.x) / zoomLevel;
                viewportY += (mouseY - newScreenPos.y) / zoomLevel;
            } else {
                // Pan
                const panSpeed = 50;
                viewportX += (e.deltaX / zoomLevel) * (panSpeed / 100);
                viewportY += (e.deltaY / zoomLevel) * (panSpeed / 100);
            }
            
            redrawCanvas();
        }

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = currentSize;
            ctx.strokeStyle = currentColor;
            
            updateCanvasSize();
        }

        function startDrawing(e) {
            if (currentTool === 'text') {
                handleTextClick(e);
                return;
            }
            
            // Handle move tool - enable panning
            if (currentTool === 'move') {
                const rect = canvas.getBoundingClientRect();
                const screenX = (e.clientX || e.touches[0].clientX) - rect.left;
                const screenY = (e.clientY || e.touches[0].clientY) - rect.top;
                
                isPanning = true;
                panStartX = screenX;
                panStartY = screenY;
                lastPanX = viewportX;
                lastPanY = viewportY;
                canvas.style.cursor = 'grabbing';
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            const screenX = (e.clientX || e.touches[0].clientX) - rect.left;
            const screenY = (e.clientY || e.touches[0].clientY) - rect.top;
            const worldPos = screenToWorld(screenX, screenY);
            const x = worldPos.x;
            const y = worldPos.y;
            
            // Check for space key + mouse for panning
            if (e.button === 1 || (e.button === 0 && e.ctrlKey && e.shiftKey)) { // Middle mouse or Ctrl+Shift+Left mouse
                isPanning = true;
                panStartX = screenX;
                panStartY = screenY;
                lastPanX = viewportX;
                lastPanY = viewportY;
                canvas.style.cursor = 'grabbing';
                return;
            }
            
            // Handle shape tools (including freehand)
            if (currentTool === 'freehand' || currentTool === 'rectangle' || currentTool === 'oval' || currentTool === 'kite' || currentTool === 'cylinder' || currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow') {
                // Check if clicking on existing shape first
                const clickedShape = findShapeAt(x, y);
                if (clickedShape) {
                    // Clear text selection when selecting shape
                    selectedTextBox = null;
                    // Only select this shape, clear any previous shape selection
                    selectedShape = clickedShape;
                    
                    // For freehand shapes, only allow dragging (no resizing)
                    if (clickedShape.type === 'freehand') {
                        isDragging = true;
                        clickedShape.lastDragX = x;
                        clickedShape.lastDragY = y;
                    } else {
                        // Check if clicking on resize handle for other shapes
                        const handle = getResizeHandle(x, y, clickedShape);
                        if (handle) {
                            isResizing = true;
                            resizeHandle = handle;
                        } else {
                            // Start dragging the shape
                            isDragging = true;
                            dragOffsetX = x - clickedShape.x;
                            dragOffsetY = y - clickedShape.y;
                        }
                    }
                    redrawCanvas();
                    return;
                }
                
                // No shape clicked, clear selection and start drawing new shape
                selectedShape = null;
                selectedTextBox = null;
                
                if (currentTool === 'freehand') {
                    isDrawingFreehand = true;
                    freehandPath = [{x: x, y: y}];
                } else {
                    isDrawingShape = true;
                    startX = x;
                    startY = y;
                }
                redrawCanvas();
                return;
            }
            
            // Handle clicking empty space (no shape found) with non-shape tools
            if (selectedShape || selectedTextBox) {
                selectedShape = null;
                selectedTextBox = null;
                redrawCanvas();
            }
            

        }

        function updateCursor(e) {
            // Don't change cursor while drawing/dragging/resizing
            if (isDragging || isResizing || isDrawingShape || isDrawingFreehand || isDraggingText) return;
            
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const worldPos = screenToWorld(screenX, screenY);
            const x = worldPos.x;
            const y = worldPos.y;
            
            // Check for text boxes when using text tool
            if (currentTool === 'text') {
                const hoveredText = findTextAt(x, y);
                if (hoveredText) {
                    canvas.style.cursor = 'move';
                    canvas.title = 'Click to drag text, double-click to edit';
                    return;
                }
            }
            
            // Check if we're over a shape manipulation tool
            if (currentTool === 'freehand' || currentTool === 'rectangle' || currentTool === 'oval' || currentTool === 'kite' || currentTool === 'cylinder' || currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow') {
                const hoveredShape = findShapeAt(x, y);
                
                if (hoveredShape) {
                    // Freehand shapes can only be moved, not resized
                    if (hoveredShape.type === 'freehand') {
                        canvas.style.cursor = 'move';
                        canvas.title = 'Drag to move freehand drawing';
                    } else {
                        const handle = getResizeHandle(x, y, hoveredShape);
                        
                        if (handle === 'nw' || handle === 'se') {
                            canvas.style.cursor = 'nw-resize';
                            canvas.title = 'Drag to resize';
                        } else if (handle === 'ne' || handle === 'sw') {
                            canvas.style.cursor = 'ne-resize';
                            canvas.title = 'Drag to resize';
                        } else {
                            // Over shape but not on handle - can move
                            canvas.style.cursor = 'move';
                            canvas.title = 'Drag to move shape';
                        }
                    }
                } else {
                    // Not over any shape - crosshair for drawing
                    canvas.style.cursor = 'crosshair';
                    if (currentTool === 'freehand') {
                        canvas.title = 'Click and drag to draw freehand';
                    } else {
                        canvas.title = 'Click and drag to draw new shape';
                    }
                }
            } else {
                // Restore default cursor for other tools
                if (currentTool === 'text') {
                    canvas.style.cursor = 'text';
                    canvas.title = 'Click to add text';
                } else if (currentTool === 'move') {
                    canvas.style.cursor = 'grab';
                    canvas.title = 'Drag to pan around canvas';
                }
            }
        }
        
        function draw(e) {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const screenX = (e.clientX || e.touches[0].clientX) - rect.left;
            const screenY = (e.clientY || e.touches[0].clientY) - rect.top;
            
            // Handle viewport panning
            if (isPanning) {
                const deltaX = screenX - panStartX;
                const deltaY = screenY - panStartY;
                viewportX = lastPanX - (deltaX / zoomLevel);
                viewportY = lastPanY - (deltaY / zoomLevel);
                redrawCanvas();
                return;
            }
            
            const worldPos = screenToWorld(screenX, screenY);
            const currentX = worldPos.x;
            const currentY = worldPos.y;
            
            // Handle shape dragging
            if (isDragging && selectedShape) {
                canvas.style.cursor = 'move';
                if (selectedShape.type === 'freehand') {
                    // For freehand shapes, move all path points
                    if (selectedShape.path) {
                        const deltaX = currentX - (selectedShape.lastDragX || currentX);
                        const deltaY = currentY - (selectedShape.lastDragY || currentY);
                        
                        if (selectedShape.lastDragX !== undefined) {
                            selectedShape.path.forEach(point => {
                                point.x += deltaX;
                                point.y += deltaY;
                            });
                        }
                        
                        selectedShape.lastDragX = currentX;
                        selectedShape.lastDragY = currentY;
                    }
                } else {
                    // For regular shapes, move x/y position
                    selectedShape.x = currentX - dragOffsetX;
                    selectedShape.y = currentY - dragOffsetY;
                }
                redrawCanvas();
                return;
            }
            
            // Handle text box dragging
            if (isDraggingText && selectedTextBox) {
                canvas.style.cursor = 'move';
                selectedTextBox.x = currentX - dragOffsetX;
                selectedTextBox.y = currentY - dragOffsetY;
                redrawCanvas();
                return;
            }
            
            // Handle shape resizing
            if (isResizing && selectedShape && resizeHandle) {
                // Set appropriate resize cursor
                if (resizeHandle === 'nw' || resizeHandle === 'se') {
                    canvas.style.cursor = 'nw-resize';
                } else if (resizeHandle === 'ne' || resizeHandle === 'sw') {
                    canvas.style.cursor = 'ne-resize';
                }
                resizeShape(selectedShape, currentX, currentY, resizeHandle);
                redrawCanvas();
                return;
            }
            
            // Handle new shape drawing preview
            if (isDrawingShape && (currentTool === 'rectangle' || currentTool === 'oval' || currentTool === 'kite' || currentTool === 'cylinder' || currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow')) {
                redrawCanvas();
                drawShapePreview(startX, startY, currentX, currentY);
                return;
            }
            
            // Handle freehand drawing
            if (isDrawingFreehand && currentTool === 'freehand') {
                freehandPath.push({x: currentX, y: currentY});
                redrawCanvas();
                // Draw the current freehand path as preview
                if (freehandPath.length > 1) {
                    ctx.save();
                    applyTransform();
                    ctx.strokeStyle = currentColor;
                    ctx.lineWidth = currentSize;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    ctx.moveTo(freehandPath[0].x, freehandPath[0].y);
                    for (let i = 1; i < freehandPath.length; i++) {
                        ctx.lineTo(freehandPath[i].x, freehandPath[i].y);
                    }
                    ctx.stroke();
                    ctx.restore();
                }
                return;
            }
        }

        function stopDrawing(e) {
            // Handle panning end
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = 'default';
                return;
            }
            // Handle new shape creation
            if (isDrawingShape) {
                const rect = canvas.getBoundingClientRect();
                const endScreenX = (e.clientX || e.touches[0].clientX) - rect.left;
                const endScreenY = (e.clientY || e.touches[0].clientY) - rect.top;
                const endWorldPos = screenToWorld(endScreenX, endScreenY);
                const endX = endWorldPos.x;
                const endY = endWorldPos.y;
                
                if (Math.abs(endX - startX) > 5 || Math.abs(endY - startY) > 5) {
                    const shape = {
                        type: currentTool,
                        x: currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow' ? startX : Math.min(startX, endX),
                        y: currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow' ? startY : Math.min(startY, endY),
                        width: currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow' ? endX : Math.abs(endX - startX),
                        height: currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow' ? endY : Math.abs(endY - startY),
                        color: currentColor,
                        lineWidth: currentSize,
                        angle: 0,
                        id: Date.now(),
                        text: '',
                        fontSize: 16,
                        fontFamily: 'Arial'
                    };
                    shapes.push(shape);
                    redrawCanvas();
                }
                isDrawingShape = false;
                saveState();
                return;
            }
            
            // Handle freehand completion
            if (isDrawingFreehand && freehandPath.length > 1) {
                const shape = {
                    type: 'freehand',
                    path: [...freehandPath], // Copy the path
                    color: currentColor,
                    lineWidth: currentSize,
                    id: Date.now()
                };
                shapes.push(shape);
                isDrawingFreehand = false;
                freehandPath = [];
                redrawCanvas();
                saveState();
                return;
            }
            
            // Handle shape manipulation end
            if (isDragging || isResizing || isDraggingText) {
                // Clean up freehand dragging state
                if (selectedShape && selectedShape.type === 'freehand') {
                    delete selectedShape.lastDragX;
                    delete selectedShape.lastDragY;
                }
                
                isDragging = false;
                isDraggingText = false;
                isResizing = false;
                resizeHandle = null;
                // Reset cursor to default for the current tool
                if (currentTool === 'freehand' || currentTool === 'rectangle' || currentTool === 'oval' || currentTool === 'kite' || currentTool === 'cylinder' || currentTool === 'line' || currentTool === 'arrow' || currentTool === 'double-arrow') {
                    canvas.style.cursor = 'crosshair';
                } else if (currentTool === 'text') {
                    canvas.style.cursor = 'text';
                }
                saveState();
                return;
            }
        }

        function handleGlobalClick(e) {
            // Don't clear selection if clicking on canvas (handled by startDrawing)
            if (e.target === canvas) return;
            
            // Don't clear if clicking on text input elements
            if (e.target.getAttribute && e.target.getAttribute('data-text-input') === 'true') return;
            if (e.target.closest && e.target.closest('[data-text-container]')) return;
            
            // Don't clear if we're currently dragging or resizing
            if (isDragging || isResizing) return;
            
            // Clear selection when clicking anywhere else (buttons, menus, toolbar, etc.)
            if (selectedShape || selectedTextBox) {
                selectedShape = null;
                selectedTextBox = null;
                redrawCanvas();
            }
        }

        function setDrawingTool(tool) {
            // Finalize any active text editing when switching tools
            if (activeTextBox && textInput && currentTool === 'text') {
                finalizeTextInput();
            }
            
            // Clear selection when switching tools, but preserve shape selection when switching back to shape tool
            if (tool !== 'shape' && !['freehand', 'rectangle', 'oval', 'kite', 'cylinder', 'line', 'arrow', 'double-arrow'].includes(tool)) {
                if (selectedShape || selectedTextBox) {
                    selectedShape = null;
                    selectedTextBox = null;
                    redrawCanvas();
                }
            }
            
            // Handle shape tool - use the current shape type
            if (tool === 'shape') {
                currentTool = currentShapeType;
            } else {
                currentTool = tool;
            }
            
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            
            // Set active button (use 'shape' for all shape types)
            const activeToolName = (tool === 'shape' || ['freehand', 'rectangle', 'oval', 'kite', 'cylinder', 'line', 'arrow', 'double-arrow'].includes(tool)) ? 'shape' : tool;
            const toolBtn = document.getElementById(activeToolName + 'Tool');
            if (toolBtn) {
                toolBtn.classList.add('active');
            }
            
            // Show/hide appropriate controls
            showToolControls(tool === 'shape' ? 'shape' : tool);
            
            // Set context properties for shapes
            if (tool === 'shape' || ['freehand', 'rectangle', 'oval', 'kite', 'cylinder', 'line', 'arrow', 'double-arrow'].includes(tool)) {
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = currentSize;
                ctx.strokeStyle = currentColor;
            }
            
            // Set initial cursor for the tool
            if (tool === 'text') {
                canvas.style.cursor = 'text';
            } else {
                canvas.style.cursor = 'crosshair';
            }
            
            const displayTool = tool === 'shape' ? currentShapeType : tool;
            document.getElementById('currentTool').textContent = displayTool.charAt(0).toUpperCase() + displayTool.slice(1);
        }
        
        function showToolControls(tool) {
            // Hide all tool controls first
            const allControls = ['textControls', 'textSeparator1', 'textSizeControls', 
                                 'textSeparator2', 'textFormatControls', 'textSeparator3', 
                                 'textColorControls', 'shapeControls', 'shapeSeparator1', 
                                 'shapeSizeControls', 'shapeSeparator2', 'shapeColorControls'];
            
            allControls.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.style.display = 'none';
            });
            
            // Show relevant controls based on tool
            switch(tool) {
                case 'text':
                    document.getElementById('textControls').style.display = 'flex';
                    document.getElementById('textSeparator1').style.display = 'flex';
                    document.getElementById('textSizeControls').style.display = 'flex';
                    document.getElementById('textSeparator2').style.display = 'flex';
                    document.getElementById('textFormatControls').style.display = 'flex';
                    document.getElementById('textSeparator3').style.display = 'flex';
                    document.getElementById('textColorControls').style.display = 'flex';
                    break;
                case 'shape':
                    document.getElementById('shapeControls').style.display = 'flex';
                    document.getElementById('shapeSeparator1').style.display = 'flex';
                    // Show size controls only for freehand
                    if (currentShapeType === 'freehand') {
                        document.getElementById('shapeSizeControls').style.display = 'flex';
                        document.getElementById('shapeSeparator2').style.display = 'flex';
                    }
                    document.getElementById('shapeColorControls').style.display = 'flex';
                    break;
            }
        }

        function setDrawingColor(color) {
            currentColor = color;
            ctx.strokeStyle = color;
            
            // Update active text input color if text tool is active
            if (currentTool === 'text' && textInput && activeTextBox) {
                textInput.style.color = color;
                textInput.style.borderColor = color;
                activeTextBox.color = color;
            }
            
            document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.color-btn').forEach(btn => {
                const btnColor = btn.style.backgroundColor || btn.style.background;
                const targetColor = color.toLowerCase();
                
                if (btnColor === targetColor || btnColor.replace(/\s/g, '') === targetColor.replace(/\s/g, '')) {
                    btn.classList.add('active');
                }
            });
        }

        function selectCustomColor(colorInput) {
            setDrawingColor(colorInput.value);
            // Clear active state from all color buttons (both pen and text)
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            // No need to set any button as active since this is a custom color
        }


        function setFontSize(size) {
            fontSize = parseInt(size);
            document.getElementById('fontSizeDisplay').textContent = size + 'px';
            
            // Update current text input if active
            if (textInput && activeTextBox) {
                textInput.style.fontSize = fontSize + 'px';
                activeTextBox.fontSize = fontSize;
                // Trigger resize
                setTimeout(() => {
                    if (textInput) {
                        const event = new Event('input');
                        textInput.dispatchEvent(event);
                    }
                }, 10);
            }
        }

        // Text formatting state
        let textBold = false;
        let textItalic = false;
        let fontFamily = 'Arial';
        
        function setFontFamily(family) {
            fontFamily = family;
            
            // Update current text input if active
            if (textInput && activeTextBox) {
                textInput.style.fontFamily = family;
                activeTextBox.fontFamily = family;
            }
        }
        

        function setShapeSize(size) {
            currentSize = size;
            document.getElementById('shapeSizeDisplay').textContent = size + 'px';
            document.getElementById('currentSizeDisplay').textContent = size + 'px';
        }
        
        function setShapeType(shapeType) {
            currentShapeType = shapeType;
            currentTool = shapeType;
            
            // Update button active states
            document.querySelectorAll('.shape-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.querySelector(`[data-shape="${shapeType}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
            
            // Update status bar
            document.getElementById('currentTool').textContent = shapeType.charAt(0).toUpperCase() + shapeType.slice(1);
            
            // Update context settings
            ctx.globalCompositeOperation = 'source-over';
            ctx.lineWidth = currentSize;
            ctx.strokeStyle = currentColor;
        }

        function toggleTextFormat(format) {
            const button = document.getElementById(format + 'Button');
            
            // Toggle global formatting for new text
            if (format === 'bold') {
                textBold = !textBold;
                button.classList.toggle('active', textBold);
            } else if (format === 'italic') {
                textItalic = !textItalic;
                button.classList.toggle('active', textItalic);
            }
            
            // Update current text input if active
            if (textInput && activeTextBox) {
                updateTextStyle(textInput, activeTextBox);
            }
        }

        function updateTextStyle(input, textBox) {
            if (!input || !textBox) return;
            
            let fontStyle = 'normal';
            let fontWeight = 'normal';
            
            if (textBold) fontWeight = 'bold';
            if (textItalic) fontStyle = 'italic';
            
            input.style.fontWeight = fontWeight;
            input.style.fontStyle = fontStyle;
            
            // Store formatting in textBox
            textBox.bold = textBold;
            textBox.italic = textItalic;
        }
        
        // Text tool functions
        function handleTextClick(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Don't create new input if clicking on existing text input
            if (e.target && e.target.getAttribute('data-text-input') === 'true') {
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX || e.touches[0].clientX) - rect.left;
            const canvasY = (e.clientY || e.touches[0].clientY) - rect.top;
            
            // Transform coordinates to account for zoom and viewport offset
            const x = (canvasX / zoomLevel) + viewportX;
            const y = (canvasY / zoomLevel) + viewportY;
            
            // Check if clicking on existing text first
            const existingText = findTextAt(x, y);
            if (existingText) {
                // Select text for dragging
                selectedTextBox = existingText;
                selectedShape = null; // Clear shape selection
                isDraggingText = true;
                dragOffsetX = x - existingText.x;
                dragOffsetY = y - existingText.y;
                
                if (activeTextBox && textInput) {
                    finalizeTextInput();
                }
                redrawCanvas();
                return;
            }
            
            // Clear any existing selections when clicking on empty space
            if (selectedTextBox || selectedShape) {
                selectedTextBox = null;
                selectedShape = null;
                redrawCanvas();
            }
            
            // Finalize any current text input first
            if (activeTextBox && textInput) {
                finalizeTextInput();
                setTimeout(() => createTextInput(x, y), 50);
                return;
            }
            
            // Create new text input
            createTextInput(x, y);
        }
        
        function findTextAt(x, y) {
            for (let i = textBoxes.length - 1; i >= 0; i--) {
                const textBox = textBoxes[i];
                
                // Calculate text dimensions for multiline text with proper formatting
                ctx.save();
                let fontString = '';
                if (textBox.bold) fontString += 'bold ';
                if (textBox.italic) fontString += 'italic ';
                fontString += (textBox.fontSize || fontSize) + 'px ' + (textBox.fontFamily || 'Arial') + ', sans-serif';
                ctx.font = fontString;
                
                const lines = textBox.text.split('\n');
                const lineHeight = (textBox.fontSize || fontSize) * 1.2;
                let maxWidth = 0;
                
                // Find the widest line
                lines.forEach(line => {
                    const lineWidth = ctx.measureText(line).width;
                    maxWidth = Math.max(maxWidth, lineWidth);
                });
                
                const totalHeight = lines.length * lineHeight;
                
                ctx.restore();
                
                // Check if click is within text bounds
                const textBounds = {
                    left: textBox.x,
                    right: textBox.x + maxWidth,
                    top: textBox.y - (textBox.fontSize || fontSize),
                    bottom: textBox.y - (textBox.fontSize || fontSize) + totalHeight
                };
                
                if (x >= textBounds.left && x <= textBounds.right &&
                    y >= textBounds.top && y <= textBounds.bottom) {
                    return textBox;
                }
            }
            return null;
        }
        
        function createTextInput(x, y) {
            saveState();
            
            // Create textarea element for multiline support
            textInput = document.createElement('textarea');
            textInput.style.position = 'absolute';
            
            // Convert world coordinates to screen coordinates for positioning  
            const screenPos = worldToScreen(x, y);
            textInput.style.left = (canvas.getBoundingClientRect().left + window.scrollX + screenPos.x) + 'px';
            textInput.style.top = (canvas.getBoundingClientRect().top + window.scrollY + screenPos.y - fontSize - 10) + 'px';
            textInput.style.zIndex = '1002';
            
            textInput.style.fontSize = fontSize + 'px';
            textInput.style.color = currentColor;
            textInput.style.background = 'rgba(255, 255, 255, 0.95)';
            textInput.style.border = '2px solid ' + currentColor;
            textInput.style.borderRadius = '4px';
            textInput.style.outline = 'none';
            textInput.style.fontFamily = 'Arial, sans-serif';
            textInput.style.padding = '6px 8px';
            textInput.style.minWidth = '100px';
            textInput.style.resize = 'both';
            textInput.style.overflow = 'auto'; // Allow scrolling for long content
            textInput.style.whiteSpace = 'pre'; // Preserve whitespace and allow long lines
            textInput.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
            textInput.style.display = 'block';
            textInput.placeholder = 'Type text...';
            textInput.setAttribute('data-text-input', 'true');
            
            document.body.appendChild(textInput);
            
            // Store the position for later
            activeTextBox = {
                id: Date.now(),
                x: x,
                y: y,
                text: '',
                color: currentColor,
                fontSize: fontSize,
                fontFamily: fontFamily,
                bold: textBold,
                italic: textItalic
            };

            // Apply current formatting to the input
            updateTextStyle(textInput, activeTextBox);
            textInput.style.fontFamily = fontFamily;
            
            // Focus and select
            textInput.focus();
            
            // Auto-resize function
            function autoResize() {
                textInput.style.height = 'auto';
                textInput.style.height = textInput.scrollHeight + 'px'; // Remove min height constraint
                textInput.style.width = 'auto';
                const minWidth = 100;
                // Remove maxWidth constraint to allow free-form longer lines
                const textWidth = Math.max(minWidth, textInput.scrollWidth + 10);
                textInput.style.width = textWidth + 'px';
            }
            
            // Add input event for auto-resizing
            textInput.addEventListener('input', autoResize);
            
            // Handle keyboard events
            textInput.addEventListener('keydown', function(e) {
                e.stopPropagation();
                
                // Ctrl+Enter or Alt+Enter to finish
                if ((e.ctrlKey || e.altKey) && e.key === 'Enter') {
                    e.preventDefault();
                    finalizeTextInput();
                }
                // Escape to cancel
                else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelTextInput();
                }
                // Allow normal Enter for new lines
                else if (e.key === 'Enter') {
                    setTimeout(autoResize, 10);
                }
            });
            
            textInput.addEventListener('keyup', autoResize);
            
            // Prevent canvas events when interacting with textarea
            textInput.addEventListener('mousedown', function(e) {
                e.stopPropagation();
            });
            
            textInput.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            // Initial auto-resize
            setTimeout(autoResize, 10);
        }
        
        function editExistingText(textBox) {
            saveState();
            
            // Remove the text from canvas first
            const index = textBoxes.indexOf(textBox);
            if (index > -1) {
                textBoxes.splice(index, 1);
                redrawCanvas();
            }
            
            // Inherit formatting from the existing text
            fontSize = textBox.fontSize || fontSize;
            fontFamily = textBox.fontFamily || fontFamily;
            textBold = textBox.bold || false;
            textItalic = textBox.italic || false;
            currentColor = textBox.color || currentColor;
            
            // Update UI controls to reflect the inherited formatting
            document.getElementById('fontSizeSlider').value = fontSize;
            document.getElementById('fontFamily').value = fontFamily;
            document.getElementById('boldButton').classList.toggle('active', textBold);
            document.getElementById('italicButton').classList.toggle('active', textItalic);
            
            // Create textarea with existing text
            textInput = document.createElement('textarea');
            textInput.style.position = 'absolute';
            
            // Convert world coordinates to screen coordinates for positioning
            const screenPos = worldToScreen(textBox.x, textBox.y);
            textInput.style.left = (canvas.getBoundingClientRect().left + window.scrollX + screenPos.x) + 'px';
            textInput.style.top = (canvas.getBoundingClientRect().top + window.scrollY + screenPos.y - (textBox.fontSize || fontSize) - 10) + 'px';
            textInput.style.zIndex = '1002';
            
            textInput.value = textBox.text;
            textInput.style.fontSize = fontSize + 'px';
            textInput.style.fontFamily = fontFamily;
            textInput.style.fontWeight = textBold ? 'bold' : 'normal';
            textInput.style.fontStyle = textItalic ? 'italic' : 'normal';
            textInput.style.color = currentColor;
            textInput.style.background = 'rgba(255, 255, 255, 0.95)';
            textInput.style.border = '2px solid ' + currentColor;
            textInput.style.borderRadius = '4px';
            textInput.style.outline = 'none';
            textInput.style.fontFamily = 'Arial, sans-serif';
            textInput.style.padding = '6px 8px';
            textInput.style.minWidth = '100px';
            textInput.style.resize = 'both';
            textInput.style.overflow = 'auto'; // Allow scrolling for long content
            textInput.style.whiteSpace = 'pre'; // Preserve whitespace and allow long lines
            textInput.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
            textInput.style.lineHeight = '1.2';
            textInput.style.display = 'block';
            textInput.placeholder = 'Type text...';
            textInput.setAttribute('data-text-input', 'true');
            
            document.body.appendChild(textInput);
            
            activeTextBox = {
                id: textBox.id, // Preserve the original ID
                x: textBox.x,
                y: textBox.y,
                text: textBox.text,
                color: textBox.color,
                fontSize: textBox.fontSize,
                fontFamily: textBox.fontFamily,
                bold: textBox.bold,
                italic: textBox.italic
            };
            
            textInput.focus();
            textInput.select();
            
            // Auto-resize function
            function autoResize() {
                textInput.style.height = 'auto';
                textInput.style.height = textInput.scrollHeight + 'px'; // Remove min height constraint
                textInput.style.width = 'auto';
                const minWidth = 100;
                // Remove maxWidth constraint to allow free-form longer lines
                const textWidth = Math.max(minWidth, textInput.scrollWidth + 10);
                textInput.style.width = textWidth + 'px';
            }
            
            textInput.addEventListener('input', autoResize);
            
            textInput.addEventListener('keydown', function(e) {
                e.stopPropagation();
                if ((e.ctrlKey || e.altKey) && e.key === 'Enter') {
                    e.preventDefault();
                    finalizeTextInput();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelTextInput();
                } else if (e.key === 'Enter') {
                    setTimeout(autoResize, 10);
                }
            });
            
            textInput.addEventListener('keyup', autoResize);
            
            textInput.addEventListener('mousedown', function(e) {
                e.stopPropagation();
            });
            
            textInput.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            setTimeout(autoResize, 10);
        }
        
        // Text formatting helper functions
        window.updateTextFontSize = function(size) {
            fontSize = parseInt(size);
            document.getElementById('textFontSize').textContent = size + 'px';
            if (textInput) {
                textInput.style.fontSize = fontSize + 'px';
                if (activeTextBox) {
                    activeTextBox.fontSize = fontSize;
                }
                // Trigger resize
                setTimeout(() => {
                    if (textInput) {
                        const event = new Event('input');
                        textInput.dispatchEvent(event);
                    }
                }, 10);
            }
        };
        
        window.applyTextFormat = function(format) {
            if (!textInput || !activeTextBox) return;
            
            if (format === 'bold') {
                const isBold = textInput.style.fontWeight === 'bold';
                textInput.style.fontWeight = isBold ? 'normal' : 'bold';
                activeTextBox.fontWeight = isBold ? 'normal' : 'bold';
            } else if (format === 'italic') {
                const isItalic = textInput.style.fontStyle === 'italic';
                textInput.style.fontStyle = isItalic ? 'normal' : 'italic';
                activeTextBox.fontStyle = isItalic ? 'normal' : 'italic';
            }
        };

        function finalizeTextInput() {
            if (!textInput || !activeTextBox) return;
            
            const text = textInput.value.trim();
            
            if (text) {
                activeTextBox.text = text;
                textBoxes.push(activeTextBox);
                drawText(activeTextBox);
                
                // Mark as modified
                const currentWb = getCurrentWhiteboard();
                if (currentWb) {
                    currentWb.modified = true;
                    renderWhiteboardTabs();
                }
            }
            
            // Clean up
            if (textInput && textInput.parentNode) {
                document.body.removeChild(textInput);
            }
            textInput = null;
            activeTextBox = null;
        }
        
        function cancelTextInput() {
            // Clean up
            if (textInput && textInput.parentNode) {
                document.body.removeChild(textInput);
            }
            textInput = null;
            activeTextBox = null;
        }
        
        function drawText(textBox) {
            ctx.save();
            
            // Apply text formatting
            let fontString = '';
            if (textBox.bold) fontString += 'bold ';
            if (textBox.italic) fontString += 'italic ';
            fontString += (textBox.fontSize || fontSize) + 'px ' + (textBox.fontFamily || 'Arial') + ', sans-serif';
            
            ctx.font = fontString;
            ctx.fillStyle = textBox.color;
            ctx.textBaseline = 'top';
            
            // Handle multiline text
            const lines = textBox.text.split('\n');
            const lineHeight = (textBox.fontSize || fontSize) * 1.2;
            
            lines.forEach((line, index) => {
                const yPos = textBox.y - (textBox.fontSize || fontSize) + (index * lineHeight);
                ctx.fillText(line, textBox.x, yPos);
            });
            
            ctx.restore();
        }
        
        function drawTextSelection(textBox) {
            // Convert text box bounds to screen coordinates for selection highlight
            ctx.save();
            
            // Calculate text dimensions
            let fontString = '';
            if (textBox.bold) fontString += 'bold ';
            if (textBox.italic) fontString += 'italic ';
            fontString += (textBox.fontSize || fontSize) + 'px ' + (textBox.fontFamily || 'Arial') + ', sans-serif';
            ctx.font = fontString;
            
            const lines = textBox.text.split('\n');
            const lineHeight = (textBox.fontSize || fontSize) * 1.2;
            let maxWidth = 0;
            
            lines.forEach(line => {
                const lineWidth = ctx.measureText(line).width;
                maxWidth = Math.max(maxWidth, lineWidth);
            });
            
            const totalHeight = lines.length * lineHeight;
            
            // Convert to screen coordinates
            const topLeft = worldToScreen(textBox.x, textBox.y - (textBox.fontSize || fontSize));
            const bottomRight = worldToScreen(textBox.x + maxWidth, textBox.y - (textBox.fontSize || fontSize) + totalHeight);
            
            // Draw selection rectangle
            ctx.strokeStyle = '#007acc';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(topLeft.x - 2, topLeft.y - 2, bottomRight.x - topLeft.x + 4, bottomRight.y - topLeft.y + 4);
            ctx.setLineDash([]);
            
            ctx.restore();
        }
        
        function redrawCanvas() {
            // Ensure all objects have IDs
            ensureObjectIds();
            
            // Clear the entire canvas
            resetTransform();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply viewport transformation for shapes and text
            applyTransform();
            
            // Draw all shapes (including freehand)
            shapes.forEach(shape => {
                drawShape(shape);
            });
            
            // Draw all text boxes
            textBoxes.forEach(textBox => {
                drawText(textBox);
            });
            
            // Reset transform for UI elements like selection
            resetTransform();
            
            // Draw selection highlight last (in screen coordinates)
            if (selectedShape) {
                drawSelection(selectedShape);
            }
            
            // Draw text box selection highlight
            if (selectedTextBox) {
                drawTextSelection(selectedTextBox);
            }
        }

        function saveState() {
            if (isRestoring) return;
            
            historyStep++;
            
            // Remove any future history if we're not at the end
            if (historyStep < drawingHistory.length) {
                drawingHistory.length = historyStep;
            }
            
            // Save current state - just the shape and text objects
            drawingHistory[historyStep] = {
                shapes: JSON.parse(JSON.stringify(shapes)),
                textBoxes: JSON.parse(JSON.stringify(textBoxes))
            };
            
            // Limit history size
            if (drawingHistory.length > 20) {
                drawingHistory.shift();
                historyStep--;
            }
        }

        function undoDrawing() {
            if (historyStep > 0) {
                historyStep--;
                restoreState(drawingHistory[historyStep]);
            }
        }

        function redoDrawing() {
            if (historyStep < drawingHistory.length - 1) {
                historyStep++;
                restoreState(drawingHistory[historyStep]);
            }
        }
        
        function restoreState(state) {
            if (!state) return;
            
            isRestoring = true;
            
            // Restore text boxes from the saved state
            if (state.textBoxes) {
                textBoxes = JSON.parse(JSON.stringify(state.textBoxes));
            } else {
                textBoxes = [];
            }
            
            // Restore shapes from the saved state (including freehand)
            if (state.shapes) {
                shapes = JSON.parse(JSON.stringify(state.shapes));
            } else {
                shapes = [];
            }
            
            // Clear selection when restoring
            selectedShape = null;
            selectedTextBox = null;
            
            // Redraw everything
            redrawCanvas();
            
            isRestoring = false;
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            textBoxes = []; // Clear all text boxes
            shapes = []; // Clear all shapes
            saveState();
            
            // Mark current whiteboard as modified
            const currentWb = getCurrentWhiteboard();
            if (currentWb) {
                currentWb.modified = true;
                renderWhiteboardTabs();
            }
        }

        function saveWhiteboard() {
            const currentWb = getCurrentWhiteboard();
            if (!currentWb) return;
            
            const dataURL = canvas.toDataURL();
            const link = document.createElement('a');
            link.download = currentWb.name;
            link.href = dataURL;
            link.click();
            
            // Mark as saved (not modified)
            currentWb.modified = false;
            renderWhiteboardTabs();
        }

        function loadWhiteboard() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.onload = function() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(img, 0, 0);
                            
                            // Update current whiteboard name and mark as modified
                            const currentWb = getCurrentWhiteboard();
                            if (currentWb) {
                                currentWb.name = file.name.replace(/\.[^/.]+$/, '') + '.png';
                                currentWb.modified = true;
                                currentWb.data = canvas.toDataURL();
                                renderWhiteboardTabs();
                            }
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }

        function toggleTheme() {
            const body = document.body;
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            body.setAttribute('data-theme', newTheme);
            
            // Update theme status display (if we had one)
            localStorage.setItem('whiteboardTheme', newTheme);
        }

        function updateCanvasSize() {
            const canvasSizeDisplay = document.getElementById('canvasSize');
            const zoomElement = document.getElementById('zoomDisplay');
            if (canvasSizeDisplay) {
                canvasSizeDisplay.textContent = `${canvas.width} x ${canvas.height}`;
            }
            if (zoomElement) {
                zoomElement.textContent = `${Math.round(zoomLevel * 100)}%`;
            }
        }

        // Initialize application
        function initializeApp() {
            // Load saved theme
            const savedTheme = localStorage.getItem('whiteboardTheme') || 'dark';
            document.body.setAttribute('data-theme', savedTheme);
            
            // Initialize canvas
            initCanvas();
            
            // Render initial tabs
            renderWhiteboardTabs();
            
            // Add keyboard shortcuts
            document.addEventListener('keydown', handleKeyboardShortcuts);
        }

        // Handle keyboard shortcuts
        function handleKeyboardShortcuts(e) {
            // Don't handle shortcuts if we're typing in a text input
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
                return;
            }
            
            const ctrlKey = e.ctrlKey || e.metaKey;
            
            if (ctrlKey) {
                switch(e.key.toLowerCase()) {
                    case 'z':
                        if (e.shiftKey) {
                            // Ctrl+Shift+Z = Redo
                            e.preventDefault();
                            e.stopPropagation();
                            redoDrawing();
                        } else {
                            // Ctrl+Z = Undo
                            e.preventDefault();
                            e.stopPropagation();
                            undoDrawing();
                        }
                        break;
                    case 'y':
                        // Ctrl+Y = Redo
                        e.preventDefault();
                        e.stopPropagation();
                        redoDrawing();
                        break;
                    case 's':
                        // Ctrl+S = Save whiteboard
                        e.preventDefault();
                        e.stopPropagation();
                        saveWhiteboard();
                        break;
                    case 'n':
                        // Ctrl+N = New whiteboard
                        e.preventDefault();
                        e.stopPropagation();
                        newWhiteboard();
                        break;
                    case 'o':
                        // Ctrl+O = Open/Load whiteboard
                        e.preventDefault();
                        e.stopPropagation();
                        loadWhiteboard();
                        break;
                    case 'c':
                        // Ctrl+C = Copy shape
                        if (selectedShape) {
                            e.preventDefault();
                            e.stopPropagation();
                            copyShape();
                        }
                        break;
                    case 'x':
                        // Ctrl+X = Cut shape
                        if (selectedShape) {
                            e.preventDefault();
                            e.stopPropagation();
                            cutShape();
                        }
                        break;
                    case 'v':
                        // Ctrl+V = Paste shape
                        e.preventDefault();
                        e.stopPropagation();
                        if (copiedShape) {
                            pasteShape();
                        }
                        break;
                }
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                // Delete selected shape
                if (selectedShape) {
                    e.preventDefault();
                    e.stopPropagation();
                    deleteShape();
                }
            } else if (e.key === 'Escape') {
                // Clear selection
                if (selectedShape) {
                    e.preventDefault();
                    e.stopPropagation();
                    selectedShape = null;
                    redrawCanvas();
                }
            }
        }
        
        // Shape manipulation functions
        function findShapeAt(x, y) {
            for (let i = shapes.length - 1; i >= 0; i--) {
                const shape = shapes[i];
                
                if (shape.type === 'freehand') {
                    // For freehand shapes, check if point is near any part of the path
                    if (shape.path && shape.path.length > 1) {
                        for (let j = 0; j < shape.path.length - 1; j++) {
                            const distance = distanceFromPointToLine(
                                x, y, 
                                shape.path[j].x, shape.path[j].y,
                                shape.path[j + 1].x, shape.path[j + 1].y
                            );
                            if (distance < 20) { // 20px tolerance for freehand selection
                                return shape;
                            }
                        }
                    }
                } else if (shape.type === 'line' || shape.type === 'arrow' || shape.type === 'double-arrow') {
                    // For lines/arrows, create a bounding box with larger padding for easier selection
                    const minX = Math.min(shape.x, shape.width) - 25;
                    const maxX = Math.max(shape.x, shape.width) + 25;
                    const minY = Math.min(shape.y, shape.height) - 25;
                    const maxY = Math.max(shape.y, shape.height) + 25;
                    
                    // First check if point is in expanded bounding box
                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                        // Then check distance to actual line with more generous tolerance
                        const distance = distanceFromPointToLine(x, y, shape.x, shape.y, shape.width, shape.height);
                        if (distance < 25) { // 25px tolerance for easier selection
                            return shape;
                        }
                    }
                } else {
                    // For rectangles and circles, use bounding box with small padding
                    if (x >= shape.x - 5 && x <= shape.x + shape.width + 5 &&
                        y >= shape.y - 5 && y <= shape.y + shape.height + 5) {
                        return shape;
                    }
                }
            }
            return null;
        }
        
        // Helper function to calculate distance from point to line
        function distanceFromPointToLine(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) {
                param = dot / lenSq;
            }
            
            let xx, yy;
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function getResizeHandle(x, y, shape) {
            const handleSize = 8;
            let selectionX, selectionY, selectionWidth, selectionHeight;
            
            // Calculate proper selection bounds
            if (shape.type === 'line' || shape.type === 'arrow' || shape.type === 'double-arrow') {
                const startX = shape.x;
                const startY = shape.y;
                const endX = shape.width;
                const endY = shape.height;
                
                selectionX = Math.min(startX, endX) - 10;
                selectionY = Math.min(startY, endY) - 10;
                selectionWidth = Math.abs(endX - startX) + 20;
                selectionHeight = Math.abs(endY - startY) + 20;
                
                if (selectionWidth < 40) {
                    selectionX -= (40 - selectionWidth) / 2;
                    selectionWidth = 40;
                }
                if (selectionHeight < 40) {
                    selectionY -= (40 - selectionHeight) / 2;
                    selectionHeight = 40;
                }
            } else {
                selectionX = shape.x - 3;
                selectionY = shape.y - 3;
                selectionWidth = shape.width + 6;
                selectionHeight = shape.height + 6;
            }
            
            const handles = [
                { name: 'nw', x: selectionX, y: selectionY },
                { name: 'ne', x: selectionX + selectionWidth, y: selectionY },
                { name: 'sw', x: selectionX, y: selectionY + selectionHeight },
                { name: 'se', x: selectionX + selectionWidth, y: selectionY + selectionHeight }
            ];
            
            for (let handle of handles) {
                if (x >= handle.x - handleSize/2 && x <= handle.x + handleSize/2 &&
                    y >= handle.y - handleSize/2 && y <= handle.y + handleSize/2) {
                    return handle.name;
                }
            }
            return null;
        }
        
        function resizeShape(shape, mouseX, mouseY, handle) {
            const minSize = 10;
            
            switch(handle) {
                case 'nw':
                    const newWidth = shape.x + shape.width - mouseX;
                    const newHeight = shape.y + shape.height - mouseY;
                    if (newWidth > minSize && newHeight > minSize) {
                        shape.width = newWidth;
                        shape.height = newHeight;
                        shape.x = mouseX;
                        shape.y = mouseY;
                    }
                    break;
                case 'ne':
                    const newWidth2 = mouseX - shape.x;
                    const newHeight2 = shape.y + shape.height - mouseY;
                    if (newWidth2 > minSize && newHeight2 > minSize) {
                        shape.width = newWidth2;
                        shape.height = newHeight2;
                        shape.y = mouseY;
                    }
                    break;
                case 'sw':
                    const newWidth3 = shape.x + shape.width - mouseX;
                    const newHeight3 = mouseY - shape.y;
                    if (newWidth3 > minSize && newHeight3 > minSize) {
                        shape.width = newWidth3;
                        shape.height = newHeight3;
                        shape.x = mouseX;
                    }
                    break;
                case 'se':
                    const newWidth4 = mouseX - shape.x;
                    const newHeight4 = mouseY - shape.y;
                    if (newWidth4 > minSize && newHeight4 > minSize) {
                        shape.width = newWidth4;
                        shape.height = newHeight4;
                    }
                    break;
            }
        }
        
        function drawSelection(shape) {
            ctx.save();
            ctx.strokeStyle = '#007acc';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            // Draw selection border
            let selectionX, selectionY, selectionWidth, selectionHeight;
            
            if (shape.type === 'line' || shape.type === 'arrow' || shape.type === 'double-arrow') {
                // For lines, create a bounding box around the actual line
                const startX = shape.x;
                const startY = shape.y;
                const endX = shape.width;  // width stores end X for lines
                const endY = shape.height; // height stores end Y for lines
                
                selectionX = Math.min(startX, endX) - 10;
                selectionY = Math.min(startY, endY) - 10;
                selectionWidth = Math.abs(endX - startX) + 20;
                selectionHeight = Math.abs(endY - startY) + 20;
                
                // Ensure minimum size for very short lines
                if (selectionWidth < 40) {
                    selectionX -= (40 - selectionWidth) / 2;
                    selectionWidth = 40;
                }
                if (selectionHeight < 40) {
                    selectionY -= (40 - selectionHeight) / 2;
                    selectionHeight = 40;
                }
            } else {
                // For rectangles and circles, use normal bounds
                selectionX = shape.x - 3;
                selectionY = shape.y - 3;
                selectionWidth = shape.width + 6;
                selectionHeight = shape.height + 6;
            }
            
            ctx.strokeRect(selectionX, selectionY, selectionWidth, selectionHeight);
            
            ctx.setLineDash([]);
            ctx.fillStyle = '#007acc';
            const handleSize = 8;
            
            // Draw resize handles
            const handles = [
                { x: selectionX, y: selectionY }, // top-left
                { x: selectionX + selectionWidth/2, y: selectionY }, // top-center
                { x: selectionX + selectionWidth, y: selectionY }, // top-right
                { x: selectionX + selectionWidth, y: selectionY + selectionHeight/2 }, // middle-right
                { x: selectionX + selectionWidth, y: selectionY + selectionHeight }, // bottom-right
                { x: selectionX + selectionWidth/2, y: selectionY + selectionHeight }, // bottom-center
                { x: selectionX, y: selectionY + selectionHeight }, // bottom-left
                { x: selectionX, y: selectionY + selectionHeight/2 } // middle-left
            ];
            
            handles.forEach(handle => {
                ctx.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
                // Add white border to make handles more visible
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.strokeRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
            });
            
            ctx.restore();
        }
        
        function copyShape() {
            if (selectedShape) {
                copiedShape = JSON.parse(JSON.stringify(selectedShape));
            }
        }
        
        function cutShape() {
            if (selectedShape) {
                copiedShape = JSON.parse(JSON.stringify(selectedShape));
                deleteShape();
            }
        }
        
        function pasteShape() {
            if (copiedShape) {
                const newShape = JSON.parse(JSON.stringify(copiedShape));
                newShape.x += 20;
                newShape.y += 20;
                newShape.id = Date.now();
                shapes.push(newShape);
                selectedShape = newShape;
                redrawCanvas();
                saveState();
            } else {
                // No copied shape available
            }
        }
        
        function deleteShape() {
            if (selectedShape) {
                const index = shapes.indexOf(selectedShape);
                if (index > -1) {
                    shapes.splice(index, 1);
                    selectedShape = null;
                    redrawCanvas();
                    saveState();
                }
            }
        }
        
        // Shape drawing and management functions
        function drawShape(shape) {
            ctx.save();
            ctx.strokeStyle = shape.color;
            ctx.lineWidth = shape.lineWidth;
            ctx.fillStyle = 'transparent';
            
            ctx.beginPath();
            if (shape.type === 'freehand') {
                // Draw freehand path
                if (shape.path && shape.path.length > 1) {
                    ctx.moveTo(shape.path[0].x, shape.path[0].y);
                    for (let i = 1; i < shape.path.length; i++) {
                        ctx.lineTo(shape.path[i].x, shape.path[i].y);
                    }
                }
            } else if (shape.type === 'rectangle') {
                ctx.rect(shape.x, shape.y, shape.width, shape.height);
            } else if (shape.type === 'oval') {
                const centerX = shape.x + shape.width / 2;
                const centerY = shape.y + shape.height / 2;
                const radiusX = shape.width / 2;
                const radiusY = shape.height / 2;
                ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            } else if (shape.type === 'kite') {
                const centerX = shape.x + shape.width / 2;
                const centerY = shape.y + shape.height / 2;
                ctx.moveTo(centerX, shape.y); // Top point
                ctx.lineTo(shape.x + shape.width, centerY); // Right point
                ctx.lineTo(centerX, shape.y + shape.height); // Bottom point
                ctx.lineTo(shape.x, centerY); // Left point
                ctx.closePath();
            } else if (shape.type === 'cylinder') {
                const centerX = shape.x + shape.width / 2;
                const topY = shape.y;
                const bottomY = shape.y + shape.height;
                const radiusX = shape.width / 2;
                const ellipseHeight = shape.height * 0.1; // 10% of height for ellipse
                
                // Draw top ellipse
                ctx.ellipse(centerX, topY, radiusX, ellipseHeight, 0, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Draw side lines
                ctx.beginPath();
                ctx.moveTo(shape.x, topY);
                ctx.lineTo(shape.x, bottomY);
                ctx.moveTo(shape.x + shape.width, topY);
                ctx.lineTo(shape.x + shape.width, bottomY);
                
                // Draw bottom ellipse (visible part)
                ctx.ellipse(centerX, bottomY, radiusX, ellipseHeight, 0, 0, Math.PI);
            } else if (shape.type === 'line') {
                ctx.moveTo(shape.x, shape.y);
                ctx.lineTo(shape.width, shape.height); // width/height store end coordinates
            } else if (shape.type === 'arrow') {
                drawArrow(ctx, shape.x, shape.y, shape.width, shape.height);
            } else if (shape.type === 'double-arrow') {
                drawDoubleArrow(ctx, shape.x, shape.y, shape.width, shape.height);
            }
            if (shape.type !== 'arrow' && shape.type !== 'double-arrow') {
                ctx.stroke();
            }
            
            // Draw text if it exists (not for freehand)
            if (shape.text && shape.text.trim() !== '' && shape.type !== 'freehand') {
                drawShapeText(shape);
            }
            
            ctx.restore();
        }

        function drawShapePreview(startX, startY, endX, endY) {
            ctx.save();
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentSize;
            ctx.setLineDash([5, 5]);

            const x = Math.min(startX, endX);
            const y = Math.min(startY, endY);
            const width = Math.abs(endX - startX);
            const height = Math.abs(endY - startY);

            ctx.beginPath();
            if (currentTool === 'rectangle') {
                ctx.rect(x, y, width, height);
            } else if (currentTool === 'oval') {
                const centerX = x + width / 2;
                const centerY = y + height / 2;
                const radiusX = width / 2;
                const radiusY = height / 2;
                ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            } else if (currentTool === 'kite') {
                const centerX = x + width / 2;
                const centerY = y + height / 2;
                ctx.moveTo(centerX, y); // Top point
                ctx.lineTo(x + width, centerY); // Right point
                ctx.lineTo(centerX, y + height); // Bottom point
                ctx.lineTo(x, centerY); // Left point
                ctx.closePath();
            } else if (currentTool === 'cylinder') {
                const centerX = x + width / 2;
                const topY = y;
                const bottomY = y + height;
                const radiusX = width / 2;
                const ellipseHeight = height * 0.1;
                
                // Draw top ellipse
                ctx.ellipse(centerX, topY, radiusX, ellipseHeight, 0, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Draw side lines and bottom ellipse
                ctx.beginPath();
                ctx.moveTo(x, topY);
                ctx.lineTo(x, bottomY);
                ctx.moveTo(x + width, topY);
                ctx.lineTo(x + width, bottomY);
                ctx.ellipse(centerX, bottomY, radiusX, ellipseHeight, 0, 0, Math.PI);
            } else if (currentTool === 'line') {
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
            } else if (currentTool === 'arrow') {
                drawArrow(ctx, startX, startY, endX, endY);
            } else if (currentTool === 'double-arrow') {
                drawDoubleArrow(ctx, startX, startY, endX, endY);
            }
            
            if (currentTool !== 'arrow' && currentTool !== 'double-arrow') {
                ctx.stroke();
            }
            ctx.restore();
        }

        // Arrow drawing functions
        function drawArrow(context, startX, startY, endX, endY) {
            const headLength = 15;
            const angle = Math.atan2(endY - startY, endX - startX);
            context.beginPath();
            context.moveTo(startX, startY);
            context.lineTo(endX, endY);
            context.stroke();
            context.beginPath();
            context.moveTo(endX, endY);
            context.lineTo(endX - headLength * Math.cos(angle - Math.PI / 6), endY - headLength * Math.sin(angle - Math.PI / 6));
            context.moveTo(endX, endY);
            context.lineTo(endX - headLength * Math.cos(angle + Math.PI / 6), endY - headLength * Math.sin(angle + Math.PI / 6));
            context.stroke();
        }
        
        function drawDoubleArrow(context, startX, startY, endX, endY) {
            const headLength = 15;
            const angle = Math.atan2(endY - startY, endX - startX);
            context.beginPath();
            context.moveTo(startX, startY);
            context.lineTo(endX, endY);
            context.stroke();
            context.beginPath();
            context.moveTo(endX, endY);
            context.lineTo(endX - headLength * Math.cos(angle - Math.PI / 6), endY - headLength * Math.sin(angle - Math.PI / 6));
            context.moveTo(endX, endY);
            context.lineTo(endX - headLength * Math.cos(angle + Math.PI / 6), endY - headLength * Math.sin(angle + Math.PI / 6));
            context.moveTo(startX, startY);
            context.lineTo(startX + headLength * Math.cos(angle - Math.PI / 6), startY + headLength * Math.sin(angle - Math.PI / 6));
            context.moveTo(startX, startY);
            context.lineTo(startX + headLength * Math.cos(angle + Math.PI / 6), startY + headLength * Math.sin(angle + Math.PI / 6));
            context.stroke();
        }

        // Shape text editing functions
        function editShapeText(shape) {
            // Only allow text editing for 2D shapes
            if (shape.type !== 'rectangle' && shape.type !== 'oval' && shape.type !== 'kite' && shape.type !== 'cylinder') {
                return;
            }
            
            // Calculate text position
            let centerX, centerY;
            
            if (shape.type === 'rectangle' || shape.type === 'oval' || shape.type === 'kite' || shape.type === 'cylinder') {
                centerX = shape.x + shape.width / 2;
                centerY = shape.y + shape.height / 2;
            }
            
            // Convert to screen coordinates
            const screenPos = worldToScreen(centerX, centerY);
            
            // Create text input element
            const textInput = document.createElement('textarea');
            textInput.value = shape.text || '';
            textInput.style.position = 'absolute';
            textInput.style.left = (canvas.getBoundingClientRect().left + window.scrollX + screenPos.x - 100) + 'px'; // Center the textarea
            textInput.style.top = (canvas.getBoundingClientRect().top + window.scrollY + screenPos.y - 40) + 'px';
            textInput.style.width = '200px';
            textInput.style.height = '80px';
            textInput.style.fontSize = (shape.fontSize || 16) + 'px';
            textInput.style.fontFamily = shape.fontFamily || 'Arial';
            textInput.style.color = shape.color;
            textInput.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
            textInput.style.border = '2px solid ' + shape.color;
            textInput.style.borderRadius = '4px';
            textInput.style.padding = '5px';
            textInput.style.zIndex = '1000';
            textInput.style.resize = 'none';
            
            document.body.appendChild(textInput);
            textInput.focus();
            textInput.select();
            
            // Handle text input completion
            function finishEditing() {
                shape.text = textInput.value;
                document.body.removeChild(textInput);
                redrawCanvas();
                saveState();
            }
            
            textInput.addEventListener('blur', finishEditing);
            textInput.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    document.body.removeChild(textInput);
                } else if (e.key === 'Enter' && e.ctrlKey) {
                    finishEditing();
                }
                e.stopPropagation();
            });
        }

        function drawShapeText(shape) {
            if (!shape.text || shape.text.trim() === '') return;

            ctx.save();
            ctx.fillStyle = shape.color;
            ctx.font = `${shape.fontSize || 16}px ${shape.fontFamily || 'Arial'}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            let centerX, centerY;

            if (shape.type === 'rectangle' || shape.type === 'oval' || shape.type === 'kite' || shape.type === 'cylinder') {
                centerX = shape.x + shape.width / 2;
                centerY = shape.y + shape.height / 2;
            } else {
                // Skip text rendering for 1D shapes
                ctx.restore();
                return;
            }

            // Split text into lines for better display
            const words = shape.text.split('\n'); // Support manual line breaks
            const maxWidth = shape.type === 'rectangle' ? shape.width - 10 : 
                           (shape.type === 'oval' || shape.type === 'kite' || shape.type === 'cylinder') ? Math.min(shape.width, shape.height) * 0.7 : 200;
            const lines = [];
            
            words.forEach(line => {
                if (line.trim() === '') {
                    lines.push('');
                    return;
                }
                
                const lineWords = line.split(' ');
                let currentLine = lineWords[0];

                for (let i = 1; i < lineWords.length; i++) {
                    const word = lineWords[i];
                    const width = ctx.measureText(currentLine + ' ' + word).width;
                    if (width < maxWidth) {
                        currentLine += ' ' + word;
                    } else {
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }
                lines.push(currentLine);
            });

            // Draw each line
            const lineHeight = (shape.fontSize || 16) * 1.2;
            const startY = centerY - ((lines.length - 1) * lineHeight) / 2;

            lines.forEach((line, index) => {
                ctx.fillText(line, centerX, startY + index * lineHeight);
            });

            ctx.restore();
        }

        // Initialize canvas when page loads
        window.addEventListener('load', initializeApp);
    </script>
</body>
</html>
