<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Editor Pro</title>
    <style>
        /* Simple, clean text editor styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }
        
        /* Theme Variables */
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #2d2d30;
            --text-primary: #d4d4d4;
            --text-secondary: #a0a0a0;
            --border-color: #3c3c3c;
            --accent-color: #61dafb;
            --highlight-bg: #264f78;
            
            /* Diff status colors */
            --diff-added: #2ea043;
            --diff-deleted: #f85149;
            --diff-modified: #dbbc37;
            
            /* RGB versions for rgba() functions */
            --bg-primary-rgb: 30, 30, 30;
            --bg-secondary-rgb: 37, 37, 38;
            --bg-tertiary-rgb: 45, 45, 48;
            --text-primary-rgb: 212, 212, 212;
            --text-secondary-rgb: 160, 160, 160;
            --border-color-rgb: 60, 60, 60;
            --accent-color-rgb: 97, 218, 251;
        }
        
        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f8f8;
            --bg-tertiary: #e8e8e8;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border-color: #cccccc;
            --accent-color: #0078d4;
            --highlight-bg: #b3d9ff;
            
            /* Diff status colors */
            --diff-added: #2ea043;
            --diff-deleted: #f85149;
            --diff-modified: #dbbc37;
            
            /* RGB versions for rgba() functions */
            --bg-primary-rgb: 255, 255, 255;
            --bg-secondary-rgb: 248, 248, 248;
            --bg-tertiary-rgb: 232, 232, 232;
            --text-primary-rgb: 51, 51, 51;
            --text-secondary-rgb: 102, 102, 102;
            --border-color-rgb: 204, 204, 204;
            --accent-color-rgb: 0, 120, 212;
        }

        .app {
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-primary);
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-primary));
            border-bottom: 1px solid var(--border-color);
            padding: 12px 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .menu-bar {
            display: flex;
            gap: 0;
            margin-right: 20px;
        }

        .header h1 {
            color: var(--accent-color);
            font-size: 20px;
            font-weight: 600;
        }

        .menu-item {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            position: relative;
            transition: all 0.2s ease;
        }

        .menu-item:hover {
            background-color: var(--bg-tertiary);
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            min-width: 180px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            display: none;
            z-index: 1000;
        }

        .menu-item:hover .dropdown-menu {
            display: block;
        }

        .dropdown-item {
            padding: 8px 16px;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 13px;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .dropdown-item:hover {
            background-color: var(--bg-tertiary);
        }

        .dropdown-separator {
            height: 1px;
            background-color: var(--border-color);
            margin: 4px 0;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .editor-area {
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .tool-panel {
            height: 100%;
            flex-direction: column;
            gap: 15px;
        }

        .editor-area h2,
        .tool-panel h2 {
            color: var(--accent-color);
            font-size: 24px;
            margin-bottom: 20px;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 8px;
            background-color: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .search-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .search-bar input {
            padding: 8px 12px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 14px;
            min-width: 150px;
        }

        .search-bar input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(97, 218, 251, 0.2);
        }

        .search-bar button {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
        }

        .search-bar button:hover {
            background-color: var(--border-color);
        }

        #searchStatus {
            color: var(--text-secondary);
            font-size: 12px;
            margin-left: 10px;
        }

        /* Buttons */
        button {
            padding: 8px 16px;
            background: var(--accent-color);
            border: none;
            border-radius: 4px;
            color: var(--bg-primary);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(var(--accent-color-rgb), 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        /* Editor */
        .editor {
            flex: 1;
            width: 100%;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            padding: 15px;
            resize: none;
            outline: none;
            line-height: 1.6;
            min-height: 400px;
            white-space: pre;
            overflow-wrap: normal;
            word-wrap: normal;
        }
        
        .editor.word-wrap {
            white-space: pre-wrap;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .editor:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(var(--accent-color-rgb), 0.2);
        }

        /* Tool Sections */
        .tool-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
        }

        .tool-section label {
            font-weight: 600;
            color: var(--accent-color);
            margin-bottom: 5px;
        }

        .tool-section textarea {
            width: 100%;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            padding: 12px;
            resize: vertical;
            outline: none;
            line-height: 1.5;
        }

        .tool-section textarea:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(var(--accent-color-rgb), 0.2);
        }

        .tool-section textarea[readonly] {
            background-color: var(--bg-primary);
            color: var(--text-secondary);
        }

        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* Compare Input Section */
        /* Compare Main Container */
        .compare-main-container {
            display: flex;
            flex-direction: column;
        }

        .compare-input-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .compare-input-side {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .diff-result {
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            max-height: 200px;
            overflow-y: auto;
            min-height: 50px;
        }

        .compare-input-side label {
            font-weight: 600;
            color: var(--accent-color);
        }

        .compare-input-side textarea {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            padding: 12px;
            resize: vertical;
            outline: none;
            line-height: 1.5;
            min-height: 120px;
        }

        .compare-input-side textarea:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(97, 218, 251, 0.2);
        }

        /* Diff Legend */
        .diff-legend {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 10px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 13px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid #3c3c3c;
        }

        .legend-color.added {
            background-color: rgba(46, 160, 67, 0.3);
            border-color: var(--diff-added);
        }

        .legend-color.deleted {
            background-color: rgba(248, 81, 73, 0.3);
            border-color: var(--diff-deleted);
        }

        .legend-color.modified {
            background-color: rgba(219, 188, 55, 0.3);
            border-color: var(--diff-modified);
        }

        .legend-color.unchanged {
            background-color: transparent;
            border-color: var(--border-color);
        }

        /* Diff Container */
        .diff-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1px;
            background-color: var(--border-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
            flex: 1; /* Takes remaining 60% height */
        }

        .diff-side {
            background-color: var(--bg-primary);
            display: flex;
            flex-direction: column;
        }

        .diff-header {
            background-color: var(--bg-tertiary);
            padding: 10px 15px;
            font-weight: 600;
            color: var(--accent-color);
            border-bottom: 1px solid var(--border-color);
            font-size: 14px;
        }

        .diff-content {
            flex: 1;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        /* Diff Lines */
        .diff-line {
            display: flex;
            min-height: 20px;
            border-bottom: 1px solid rgba(var(--border-color-rgb), 0.3);
        }

        .diff-line.equal {
            background-color: transparent;
        }

        .diff-line.insert {
            background-color: rgba(46, 160, 67, 0.15);
            border-left: 3px solid #2ea043;
        }

        .diff-line.delete {
            background-color: rgba(248, 81, 73, 0.15);
            border-left: 3px solid #f85149;
        }

        .diff-line.modify {
            background-color: rgba(225, 197, 72, 0.15);
            border-left: 3px solid #dbbc37;
        }

        .line-number {
            display: inline-block;
            width: 50px;
            padding: 2px 8px;
            text-align: right;
            color: var(--text-secondary);
            background-color: rgba(var(--bg-tertiary-rgb), 0.5);
            border-right: 1px solid var(--border-color);
            font-size: 11px;
            user-select: none;
            flex-shrink: 0;
        }

        .line-content {
            padding: 2px 12px;
            flex: 1;
            white-space: pre;
            overflow-x: auto;
            min-height: 16px;
        }

        .diff-line.insert .line-content {
            color: #2ea043;
        }

        .diff-line.delete .line-content {
            color: #f85149;
        }

        .diff-line.modify .line-content {
            color: #d4d4d4;
        }

        .diff-line.equal .line-content {
            color: #d4d4d4;
        }

        /* Compare Stats */
        .compare-stats {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
        }

        .compare-stats p {
            margin-bottom: 8px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
        }

        .stat-added {
            color: #2ea043;
            font-weight: 600;
        }

        .stat-deleted {
            color: #f85149;
            font-weight: 600;
        }

        .stat-modified {
            color: #dbbc37;
            font-weight: 600;
        }

        /* File Tabs */
        .file-tabs {
            display: flex;
            background-color: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
            min-height: 40px;
        }

        .file-tab {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            background-color: var(--bg-primary);
            border-right: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            white-space: nowrap;
            min-width: 120px;
            position: relative;
        }

        .file-tab.active {
            background-color: var(--bg-secondary);
            color: var(--accent-color);
        }

        .file-tab:hover {
            background-color: var(--bg-tertiary);
        }

        .file-tab.modified::after {
            content: '●';
            margin-left: 5px;
            color: var(--diff-deleted);
        }

        .file-tab.compare-first {
            border-left: 3px solid var(--diff-added);
        }

        .file-tab-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-tab-close {
            margin-left: 8px;
            padding: 2px 6px;
            border-radius: 3px;
            opacity: 0.7;
        }

        .file-tab-close:hover {
            opacity: 1;
            background-color: #f85149;
        }

        .new-file-btn {
            padding: 8px 16px;
            background-color: transparent;
            border: none;
            color: var(--accent-color);
            cursor: pointer;
            border-right: 1px solid var(--border-color);
        }

        .new-file-btn:hover {
            background-color: #2d2d30;
        }

        /* Dialog Styles */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }

        .dialog {
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            min-width: 450px;
            max-width: 600px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
        }

        .dialog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-tertiary);
            border-radius: 8px 8px 0 0;
        }

        .dialog-header h3 {
            margin: 0;
            color: var(--accent-color);
            font-size: 16px;
        }

        .dialog-close {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .dialog-close:hover {
            background-color: #f85149;
            color: white;
        }

        .dialog-content {
            padding: 20px;
        }

        .dialog-row {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dialog-row label:first-child {
            min-width: 80px;
            color: var(--text-primary);
            font-size: 13px;
        }

        .dialog-row input[type="text"] {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 13px;
        }

        .dialog-row input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .radio-group {
            display: flex;
            gap: 15px;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 5px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 13px;
            min-width: auto !important;
        }

        .radio-label input[type="radio"] {
            margin: 0;
        }

        .dialog-row button {
            padding: 8px 16px;
            margin-right: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
        }

        .dialog-row button:hover {
            background-color: var(--border-color);
        }

        .dialog-row button:last-child {
            margin-right: 0;
        }

        #findReplaceStatus {
            color: var(--text-secondary);
            font-size: 12px;
            font-style: italic;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background-color: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            padding: 4px 0;
            z-index: 1000;
            min-width: 180px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            display: none;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            color: #d4d4d4;
            font-size: 13px;
        }

        .context-menu-item:hover {
            background-color: #2d2d30;
        }

        .context-menu-item.disabled {
            color: #666;
            cursor: not-allowed;
        }

        .context-menu-item.disabled:hover {
            background-color: transparent;
        }

        .context-menu-separator {
            height: 1px;
            background-color: #3c3c3c;
            margin: 4px 0;
        }

        /* File Operations Bar */
        .file-operations {
            display: flex;
            align-items: center;
            padding: 8px 20px;
            background-color: #2d2d30;
            border-bottom: 1px solid #3c3c3c;
            gap: 10px;
        }

        .file-operations button {
            padding: 6px 12px;
            font-size: 12px;
        }
        .status-bar {
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
            border-top: 1px solid var(--border-color);
            padding: 8px 20px;
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        /* Syntax Highlighting */
        .syntax-keyword { color: #569cd6; font-weight: bold; }
        .syntax-string { color: #ce9178; }
        .syntax-comment { color: #6a9955; font-style: italic; }
        .syntax-number { color: #b5cea8; }
        .syntax-operator { color: #d4d4d4; }
        .syntax-function { color: #dcdcaa; }
        .syntax-tag { color: #569cd6; }
        .syntax-attribute { color: #9cdcfe; }
        .syntax-value { color: #ce9178; }
        .syntax-bracket { color: #ffd700; font-weight: bold; }
        
        /* Code Folding */
        .fold-marker {
            display: inline-block;
            width: 12px;
            height: 12px;
            line-height: 10px;
            text-align: center;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            font-size: 10px;
            margin-right: 5px;
            user-select: none;
        }
        
        .fold-marker:hover {
            background: var(--highlight-bg);
        }
        
        .folded-content {
            color: var(--text-secondary);
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
        }
        
        /* Submenu styles */
        .dropdown-submenu {
            position: absolute;
            left: 100%;
            top: 0;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            min-width: 180px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            z-index: 1001;
        }

        /* Responsive */
        /* Syntax highlighting styles */
        .syntax-js {
            background-color: inherit !important;
        }
        
        .syntax-python {
            background-color: inherit !important;
        }
        
        .syntax-html {
            background-color: inherit !important;
        }
        
        .syntax-css {
            background-color: inherit !important;
        }
        
        /* Ensure editor maintains proper layout */
        .editor {
            min-height: 400px !important;
            height: calc(100vh - 200px) !important;
            resize: none !important;
        }

        /* Word wrap styling */
        .word-wrap-enabled {
            white-space: pre-wrap !important;
            word-break: break-word !important;
            overflow-wrap: break-word !important;
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
            }
            
            .compare-input-container {
                grid-template-columns: 1fr;
            }
            
            .diff-container {
                grid-template-columns: 1fr;
                min-height: 300px;
            }
            
            .diff-legend {
                flex-direction: column;
                gap: 10px;
            }
            
            .search-bar {
                flex-direction: column;
                align-items: stretch;
            }
            
            .search-bar input {
                min-width: unset;
            }
            
            .line-number {
                width: 40px;
                padding: 2px 4px;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Header -->
        <div class="header">
            <div class="menu-bar">
                <div class="menu-item">
                    File
                    <div class="dropdown-menu">
                        <button class="dropdown-item" onclick="newFile()">New (Ctrl+N)</button>
                        <button class="dropdown-item" onclick="openFile()">Open (Ctrl+O)</button>
                        <div class="dropdown-separator"></div>
                        <button class="dropdown-item" onclick="saveFile()">Save (Ctrl+S)</button>
                        <button class="dropdown-item" onclick="saveAsFile()">Save As (Ctrl+Shift+S)</button>
                        <button class="dropdown-item" onclick="toggleAutoSave()">Auto-save: <span id="autoSaveStatus">Off</span></button>
                        <div class="dropdown-separator"></div>
                        <button class="dropdown-item" onclick="renameCurrentFile()">Rename File (Ctrl+Shift+R)</button>
                        <div class="dropdown-separator"></div>
                        <button class="dropdown-item" onclick="closeCurrentFile()">Close File</button>
                    </div>
                </div>
                <div class="menu-item">
                    Edit
                    <div class="dropdown-menu">
                        <button class="dropdown-item" onclick="undo()">Undo (Ctrl+Z)</button>
                        <button class="dropdown-item" onclick="redo()">Redo (Ctrl+Y)</button>
                        <div class="dropdown-separator"></div>
                        <button class="dropdown-item" onclick="showFindReplaceDialog()">Find & Replace (Ctrl+F)</button>
                        <div class="dropdown-separator"></div>
                        <button class="dropdown-item" onclick="duplicateLine()">Duplicate Line (Ctrl+D)</button>
                        <button class="dropdown-item" onclick="deleteLine()">Delete Line (Ctrl+L)</button>
                        <button class="dropdown-item" onclick="moveLineUp()">Move Line Up (Ctrl+Shift+↑)</button>
                        <button class="dropdown-item" onclick="moveLineDown()">Move Line Down (Ctrl+Shift+↓)</button>
                        <button class="dropdown-item" onclick="showSortLinesDialog()">Sort Lines</button>
                        <div class="dropdown-separator"></div>
                        <button class="dropdown-item" onclick="transformToUpperCase()">UPPERCASE</button>
                        <button class="dropdown-item" onclick="transformToLowerCase()">lowercase</button>
                        <button class="dropdown-item" onclick="transformToTitleCase()">Title Case</button>
                        <button class="dropdown-item" onclick="trimWhitespace()">Trim Whitespace</button>
                        <button class="dropdown-item" onclick="removeEmptyLines()">Remove Empty Lines</button>
                    </div>
                </div>
                <div class="menu-item">
                    View
                    <div class="dropdown-menu">
                        <button class="dropdown-item" onclick="toggleWordWrap()">Word Wrap: <span id="wordWrapStatus">Off</span></button>
                        <button class="dropdown-item" onclick="toggleSyntaxHighlight()">Syntax Highlight: <span id="syntaxStatus">On</span></button>
                        <button class="dropdown-item" onclick="toggleTheme()">Theme: <span id="themeStatus">Dark</span></button>
                    </div>
                </div>
                <div class="menu-item">
                    Plugins
                    <div class="dropdown-menu">
                        <button class="dropdown-item" onclick="base64EncodeCurrentSelection()">Base64 Encode</button>
                        <button class="dropdown-item" onclick="base64DecodeCurrentSelection()">Base64 Decode</button>
                    </div>
                </div>
                <div class="menu-item">
                    Format
                    <div class="dropdown-menu">
                        <button class="dropdown-item" onclick="formatCurrentFileAsJSON()">JSON Pretty Print</button>
                        <div class="dropdown-separator"></div>
                        <button class="dropdown-item" onclick="formatCurrentFileAsXML()">XML Pretty Print</button>
                    </div>
                </div>
                <div class="menu-item">
                    Compare
                    <div class="dropdown-menu">
                        <button class="dropdown-item" onclick="showComparePanel()">Text Comparison</button>
                        <div class="dropdown-separator"></div>
                        <button class="dropdown-item" onclick="setCurrentAsFirstCompare()">Set Current as First</button>
                        <button class="dropdown-item" onclick="compareWithFirstFile()">Compare with First</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <input type="file" id="fileInput" style="display: none" accept=".txt,.js,.html,.css,.json,.xml,.md" multiple onchange="handleFileOpen(event)">
            
            <!-- Main Editor Area -->
            <div id="main-editor" class="editor-area active">
                <div class="file-tabs" id="fileTabs">
                    <button class="new-file-btn" onclick="newFile()">+</button>
                </div>
                
                <div class="toolbar">
                    <!-- Toolbar can be used for other controls in the future -->
                </div>
                
                <textarea id="editorContent" class="editor" 
                    placeholder="Start typing your content here..."></textarea>
                
                <div class="status-bar">
                    <span id="currentFileName">File: untitled.txt</span>
                    <span id="statusLines">Lines: 1</span>
                    <span id="statusChars">Characters: 0</span>
                    <span id="statusWords">Words: 0</span>
                    <span id="statusSelection">Sel: 0</span>
                    <span id="statusPosition">Ln: 1, Col: 1</span>
                    <span id="statusLanguage">Plain Text</span>
                </div>
            </div>

            <!-- Plugins Panel (hidden by default) -->
            <div id="plugins-panel" class="tool-panel" style="display: none;">
                <h2>Plugins</h2>
                
                <div class="tool-section">
                    <label>Input Text:</label>
                    <textarea id="base64Input" placeholder="Enter text to encode/decode..." rows="6"></textarea>
                    
                    <div class="buttons">
                        <button onclick="handleBase64Encode()">Base64 Encode</button>
                        <button onclick="handleBase64Decode()">Base64 Decode</button>
                        <button onclick="loadToEditor('base64Output')">Load to Editor</button>
                    </div>
                    
                    <label>Output:</label>
                    <textarea id="base64Output" readonly placeholder="Result will appear here..." rows="6"></textarea>
                </div>
            </div>

            <!-- Format Panel (hidden by default) -->
            <div id="format-panel" class="tool-panel" style="display: none;">
                <h2>JSON/XML Formatter</h2>
                
                <div class="tool-section">
                    <label>Input (JSON or XML):</label>
                    <textarea id="jsonInput" placeholder='Enter JSON like: {"name":"John","age":30} or XML like: <root><item>value</item></root>' rows="8"></textarea>
                    
                    <div class="buttons">
                        <button onclick="handleFormatJSON()">JSON Pretty Print</button>
                        <button onclick="handleFormatXML()">XML Pretty Print</button>
                        <button onclick="loadToEditor('jsonOutput')">Load to Editor</button>
                    </div>
                    
                    <label>Formatted Output:</label>
                    <textarea id="jsonOutput" readonly placeholder="Formatted result will appear here..." rows="8"></textarea>
                </div>
            </div>

            <!-- Compare Panel (hidden by default) -->
            <div id="compare-panel" class="tool-panel" style="display: none;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px;">
                    <button onclick="hideAllPanels()" style="padding: 6px 12px;">← Back to Editor</button>
                    <h2 style="margin: 0;">Text Comparison</h2>
                </div>
                
                <!-- Legend and Statistics at top -->
                <div class="diff-legend">
                    <div class="legend-item">
                        <span class="legend-color added"></span>
                        <span>Added (Green)</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color deleted"></span>
                        <span>Deleted (Red)</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color modified"></span>
                        <span>Modified (Yellow)</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color unchanged"></span>
                        <span>Unchanged</span>
                    </div>
                </div>
                
                <!-- Statistics -->
                <div class="compare-stats" id="compareStats" style="margin-bottom: 20px;"></div>
                
                <!-- Input and Diff Sections with equal height -->
                <div class="compare-main-container">
                    <!-- Input Section with inline diff results -->
                    <div class="compare-input-container">
                        <div class="compare-input-side">
                            <label>Left Text:</label>
                            <textarea id="compareLeft" placeholder="Enter first text..." onchange="updateDiff()" oninput="updateDiff()">test
text</textarea>
                            <div class="diff-result" id="diffLeft"></div>
                        </div>
                        
                        <div class="compare-input-side">
                            <label>Right Text:</label>
                            <textarea id="compareRight" placeholder="Enter second text..." onchange="updateDiff()" oninput="updateDiff()">text
text</textarea>
                            <div class="diff-result" id="diffRight"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Find/Replace Dialog -->
    <div id="findReplaceDialog" class="dialog-overlay" style="display: none;">
        <div class="dialog">
            <div class="dialog-header">
                <h3>Find & Replace</h3>
                <button class="dialog-close" onclick="closeFindReplaceDialog()">×</button>
            </div>
            <div class="dialog-content">
                <div class="dialog-row">
                    <label for="findInput">Find:</label>
                    <input type="text" id="findInput" placeholder="Enter text to find..." onkeyup="if(event.key==='Enter') findNext()">
                </div>
                <div class="dialog-row">
                    <label for="replaceInput">Replace with:</label>
                    <input type="text" id="replaceInput" placeholder="Enter replacement text...">
                </div>
                <div class="dialog-row">
                    <label>Scope:</label>
                    <div class="radio-group">
                        <label class="radio-label">
                            <input type="radio" name="scope" value="current" checked>
                            Current file
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="scope" value="all">
                            All opened files
                        </label>
                    </div>
                </div>
                <div class="dialog-row">
                    <button onclick="findNext()">Find Next</button>
                    <button onclick="findPrevious()">Find Previous</button>
                    <button onclick="replaceNext()">Replace & Find Next</button>
                    <button onclick="replaceAll()">Replace All</button>
                    <button onclick="closeFindReplaceDialog()">Close</button>
                </div>
                <div class="dialog-row">
                    <span id="findReplaceStatus"></span>
                </div>
            </div>
        </div>
    </div>

    <!-- Context Menus -->
    <div id="textContextMenu" class="context-menu">
        <div class="context-menu-item" onclick="base64EncodeSelection()">Base64 Encode</div>
        <div class="context-menu-item" onclick="base64DecodeSelection()">Base64 Decode</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="copySelection()">Copy</div>
        <div class="context-menu-item" onclick="cutSelection()">Cut</div>
        <div class="context-menu-item" onclick="pasteAtCursor()">Paste</div>
    </div>

    <div id="fileTabContextMenu" class="context-menu">
        <div class="context-menu-item" onclick="setAsFirstCompare()">Set as First to Compare</div>
        <div class="context-menu-item" onclick="compareWithFirst()">Compare with First</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="clearCompareSelection()">Clear Compare</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="renameFile()">Rename</div>
        <div class="context-menu-item" onclick="closeFile(currentContextFileId)">Close</div>
    </div>

    <script>
        // Global state
        let files = [{
            id: 'file_0',
            name: 'untitled.txt',
            content: ``,
            modified: false,
            path: null,
            undoStack: [],
            redoStack: [],
            language: 'text'
        }];
        let activeFileId = 'file_0';
        let fileCounter = 1;
        let compareFirstFileId = null;
        let currentContextFileId = null;
        
        // New feature states
        let autoSaveInterval = null;
        let currentTheme = localStorage.getItem('theme') || 'dark';
        let wordWrapEnabled = localStorage.getItem('wordWrap') === 'true';
        let syntaxHighlightEnabled = true;

        // File Management
        function newFile() {
            const fileId = `file_${fileCounter++}`;
            const newFile = {
                id: fileId,
                name: `untitled${fileCounter-1}.txt`,
                content: '',
                modified: false,
                path: null,
                undoStack: [],
                redoStack: [],
                language: 'text'
            };
            files.push(newFile);
            switchToFile(fileId);
            renderFileTabs();
        }

        function openFile() {
            document.getElementById('fileInput').click();
        }

        function handleFileOpen(event) {
            const fileList = event.target.files;
            for (let file of fileList) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const fileId = `file_${fileCounter++}`;
                    const newFile = {
                        id: fileId,
                        name: file.name,
                        content: e.target.result,
                        modified: false,
                        path: file.name,
                        undoStack: [],
                        redoStack: [],
                        language: detectLanguage(file.name)
                    };
                    files.push(newFile);
                    switchToFile(fileId);
                    renderFileTabs();
                    applySyntaxHighlighting();
                };
                reader.readAsText(file);
            }
        }

        function saveFile() {
            const currentFile = getCurrentFile();
            if (!currentFile) return;
            
            // Get current editor content and update file
            const editorContent = document.getElementById('editorContent').value;
            currentFile.content = editorContent;
            
            // Download the file (this is how web browsers "save")
            downloadFile(currentFile.content, currentFile.name);
            
            // Mark as saved and update file path if it was new
            if (!currentFile.path) {
                currentFile.path = currentFile.name;
            }
            currentFile.modified = false;
            renderFileTabs();
            updateStatus();
        }

        function saveAsFile() {
            const currentFile = getCurrentFile();
            if (!currentFile) return;
            
            // Get current editor content
            const editorContent = document.getElementById('editorContent').value;
            currentFile.content = editorContent;
            
            const filename = prompt('Enter filename:', currentFile.name);
            if (filename && filename.trim()) {
                const trimmedFilename = filename.trim();
                
                // Download the file with new name
                downloadFile(currentFile.content, trimmedFilename);
                
                // Update current file with new name
                currentFile.name = trimmedFilename;
                currentFile.path = trimmedFilename;
                currentFile.modified = false;
                currentFile.language = detectLanguage(trimmedFilename);
                
                renderFileTabs();
                updateStatus();
                applySyntaxHighlighting();
            }
        }

        function downloadFile(content, filename) {
            const element = document.createElement('a');
            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(content));
            element.setAttribute('download', filename);
            element.style.display = 'none';
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }

        function switchToFile(fileId) {
            const currentFile = getCurrentFile();
            if (currentFile) {
                const newContent = document.getElementById('editorContent').value;
                if (currentFile.content !== newContent) {
                    currentFile.content = newContent;
                    currentFile.modified = true;
                }
            }
            
            activeFileId = fileId;
            const file = files.find(f => f.id === fileId);
            if (file) {
                document.getElementById('editorContent').value = file.content;
                updateStatus();
                renderFileTabs();
            }
        }

        function closeFile(fileId) {
            const fileIndex = files.findIndex(f => f.id === fileId);
            if (fileIndex === -1) return;
            
            const file = files[fileIndex];
            if (file.modified) {
                if (!confirm(`File "${file.name}" has unsaved changes. Close anyway?`)) {
                    return;
                }
            }
            
            files.splice(fileIndex, 1);
            
            if (fileId === activeFileId) {
                if (files.length > 0) {
                    const newActiveFile = files[Math.max(0, fileIndex - 1)];
                    switchToFile(newActiveFile.id);
                } else {
                    newFile();
                }
            }
            
            if (compareFirstFileId === fileId) {
                compareFirstFileId = null;
            }
            
            renderFileTabs();
        }

        function getCurrentFile() {
            return files.find(f => f.id === activeFileId);
        }
        
        // Undo/Redo System
        function pushToUndoStack(content) {
            const currentFile = getCurrentFile();
            if (currentFile) {
                if (currentFile.undoStack.length > 100) {
                    currentFile.undoStack.shift();
                }
                currentFile.undoStack.push(content);
                currentFile.redoStack = []; // Clear redo stack when new change is made
            }
        }
        
        function undo() {
            const currentFile = getCurrentFile();
            if (!currentFile || currentFile.undoStack.length === 0) return;
            
            const editor = document.getElementById('editorContent');
            const currentContent = editor.value;
            
            // Push current state to redo stack
            if (currentFile.redoStack.length > 100) {
                currentFile.redoStack.shift();
            }
            currentFile.redoStack.push(currentContent);
            
            // Get previous state
            const previousContent = currentFile.undoStack.pop();
            editor.value = previousContent;
            currentFile.content = previousContent;
            currentFile.modified = true;
            renderFileTabs();
            updateStatus();
            applySyntaxHighlighting();
        }
        
        function redo() {
            const currentFile = getCurrentFile();
            if (!currentFile || currentFile.redoStack.length === 0) return;
            
            const editor = document.getElementById('editorContent');
            const currentContent = editor.value;
            
            // Push current state back to undo stack
            if (currentFile.undoStack.length > 100) {
                currentFile.undoStack.shift();
            }
            currentFile.undoStack.push(currentContent);
            
            // Get next state
            const nextContent = currentFile.redoStack.pop();
            editor.value = nextContent;
            currentFile.content = nextContent;
            currentFile.modified = true;
            renderFileTabs();
            updateStatus();
            applySyntaxHighlighting();
        }

        // Text Transformations
        function transformToUpperCase() {
            const editor = document.getElementById('editorContent');
            const selectedText = getSelectedText(editor);
            
            if (selectedText) {
                pushToUndoStack(editor.value);
                replaceSelectedText(editor, selectedText.toUpperCase());
                markCurrentFileAsModified();
            } else {
                pushToUndoStack(editor.value);
                editor.value = editor.value.toUpperCase();
                markCurrentFileAsModified();
                updateStatus();
                applySyntaxHighlighting();
            }
        }
        
        function transformToLowerCase() {
            const editor = document.getElementById('editorContent');
            const selectedText = getSelectedText(editor);
            
            if (selectedText) {
                pushToUndoStack(editor.value);
                replaceSelectedText(editor, selectedText.toLowerCase());
                markCurrentFileAsModified();
            } else {
                pushToUndoStack(editor.value);
                editor.value = editor.value.toLowerCase();
                markCurrentFileAsModified();
                updateStatus();
                applySyntaxHighlighting();
            }
        }
        
        function transformToTitleCase() {
            const editor = document.getElementById('editorContent');
            const selectedText = getSelectedText(editor);
            
            const toTitleCase = (str) => {
                return str.replace(/\w\S*/g, (txt) => {
                    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                });
            };
            
            if (selectedText) {
                pushToUndoStack(editor.value);
                replaceSelectedText(editor, toTitleCase(selectedText));
                markCurrentFileAsModified();
            } else {
                pushToUndoStack(editor.value);
                editor.value = toTitleCase(editor.value);
                markCurrentFileAsModified();
                updateStatus();
                applySyntaxHighlighting();
            }
        }
        
        function trimWhitespace() {
            const editor = document.getElementById('editorContent');
            const content = editor.value;
            const lines = content.split('\n');
            
            pushToUndoStack(editor.value);
            
            const trimmedLines = lines.map(line => line.trimEnd());
            editor.value = trimmedLines.join('\n');
            markCurrentFileAsModified();
            updateStatus();
            applySyntaxHighlighting();
        }
        
        function removeEmptyLines() {
            const editor = document.getElementById('editorContent');
            const content = editor.value;
            const lines = content.split('\n');
            
            pushToUndoStack(editor.value);
            
            const nonEmptyLines = lines.filter(line => line.trim() !== '');
            editor.value = nonEmptyLines.join('\n');
            markCurrentFileAsModified();
            updateStatus();
            applySyntaxHighlighting();
        }
        
        // Direct Menu Action Functions
        function duplicateLine() {
            const editor = document.getElementById('editorContent');
            const start = editor.selectionStart;
            const content = editor.value;
            
            // Find the start and end of current line
            const lineStart = content.lastIndexOf('\n', start - 1) + 1;
            const lineEnd = content.indexOf('\n', start);
            const line = lineEnd === -1 ? content.substring(lineStart) : content.substring(lineStart, lineEnd + 1);
            
            pushToUndoStack(editor.value);
            
            if (lineEnd === -1) {
                // Last line without \n
                editor.value = content + '\n' + line.trimEnd();
            } else {
                editor.value = content.substring(0, lineEnd + 1) + line + content.substring(lineEnd + 1);
            }
            
            markCurrentFileAsModified();
            updateStatus();
            applySyntaxHighlighting();
        }
        
        function deleteLine() {
            const editor = document.getElementById('editorContent');
            const start = editor.selectionStart;
            const content = editor.value;
            
            pushToUndoStack(editor.value);
            
            // Find the start and end of current line
            const lineStart = content.lastIndexOf('\n', start - 1) + 1;
            const lineEnd = content.indexOf('\n', start);
            
            if (lineEnd === -1) {
                // Last line
                if (lineStart === 0) {
                    // Only line
                    editor.value = '';
                } else {
                    // Remove the line and the preceding newline
                    editor.value = content.substring(0, lineStart - 1);
                }
            } else {
                // Remove line including newline
                editor.value = content.substring(0, lineStart) + content.substring(lineEnd + 1);
            }
            
            editor.selectionStart = editor.selectionEnd = Math.min(lineStart, editor.value.length);
            markCurrentFileAsModified();
            updateStatus();
            applySyntaxHighlighting();
        }
        
        function moveLineUp() {
            const editor = document.getElementById('editorContent');
            const start = editor.selectionStart;
            const content = editor.value;
            const lines = content.split('\n');
            
            // Find current line number
            const beforeCursor = content.substring(0, start);
            const currentLineIndex = beforeCursor.split('\n').length - 1;
            
            if (currentLineIndex === 0) return; // Already at top
            
            pushToUndoStack(editor.value);
            
            // Swap lines
            [lines[currentLineIndex - 1], lines[currentLineIndex]] = [lines[currentLineIndex], lines[currentLineIndex - 1]];
            
            editor.value = lines.join('\n');
            markCurrentFileAsModified();
            updateStatus();
            applySyntaxHighlighting();
        }
        
        function moveLineDown() {
            const editor = document.getElementById('editorContent');
            const start = editor.selectionStart;
            const content = editor.value;
            const lines = content.split('\n');
            
            // Find current line number
            const beforeCursor = content.substring(0, start);
            const currentLineIndex = beforeCursor.split('\n').length - 1;
            
            if (currentLineIndex === lines.length - 1) return; // Already at bottom
            
            pushToUndoStack(editor.value);
            
            // Swap lines
            [lines[currentLineIndex], lines[currentLineIndex + 1]] = [lines[currentLineIndex + 1], lines[currentLineIndex]];
            
            editor.value = lines.join('\n');
            markCurrentFileAsModified();
            updateStatus();
            applySyntaxHighlighting();
        }
        
        function sortLines() {
            showSortLinesDialog();
        }
        // UTF-8 safe Base64 encoding
        function utf8ToBase64(str) {
            try {
                // Use TextEncoder for modern browsers
                if (typeof TextEncoder !== 'undefined') {
                    const encoder = new TextEncoder();
                    const bytes = encoder.encode(str);
                    let binary = '';
                    bytes.forEach(byte => binary += String.fromCharCode(byte));
                    return btoa(binary);
                } else {
                    // Fallback for older browsers
                    return btoa(unescape(encodeURIComponent(str)));
                }
            } catch (error) {
                throw new Error('Failed to encode text to Base64');
            }
        }

        function base64ToUtf8(base64) {
            try {
                // Add proper padding if needed
                const paddedBase64 = base64 + "=".repeat((4 - base64.length % 4) % 4);
                
                // Use TextDecoder for modern browsers
                if (typeof TextDecoder !== 'undefined') {
                    const binary = atob(paddedBase64);
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) {
                        bytes[i] = binary.charCodeAt(i);
                    }
                    const decoder = new TextDecoder();
                    return decoder.decode(bytes);
                } else {
                    // Fallback for older browsers
                    return decodeURIComponent(escape(atob(paddedBase64)));
                }
            } catch (error) {
                throw new Error('Failed to decode Base64 to text');
            }
        }

        function base64EncodeCurrentSelection() {
            const editor = document.getElementById('editorContent');
            const selectedText = getSelectedText(editor);
            if (selectedText) {
                try {
                    // Save current state to undo stack
                    pushToUndoStack(editor.value);
                    
                    const encoded = utf8ToBase64(selectedText);
                    replaceSelectedText(editor, encoded);
                    markCurrentFileAsModified();
                } catch (error) {
                    alert('Error: Failed to encode text to Base64 - ' + error.message);
                }
            } else {
                alert('Please select text to encode');
            }
        }
        
        function base64DecodeCurrentSelection() {
            const editor = document.getElementById('editorContent');
            const selectedText = getSelectedText(editor);
            if (selectedText) {
                try {
                    // Save current state to undo stack
                    pushToUndoStack(editor.value);
                    
                    const decoded = base64ToUtf8(selectedText);
                    replaceSelectedText(editor, decoded);
                    markCurrentFileAsModified();
                } catch (error) {
                    alert('Error: Failed to decode Base64 - ' + error.message);
                }
            } else {
                alert('Please select text to decode');
            }
        }
        
        function formatCurrentFileAsJSON() {
            const editor = document.getElementById('editorContent');
            const content = editor.value;
            try {
                // Save current state to undo stack
                pushToUndoStack(content);
                
                const parsed = JSON.parse(content);
                const formatted = JSON.stringify(parsed, null, 2);
                editor.value = formatted;
                markCurrentFileAsModified();
                updateStatus();
            } catch (error) {
                alert('Error: Invalid JSON format in current file');
            }
        }
        

        
        function formatCurrentFileAsXML() {
            const editor = document.getElementById('editorContent');
            const content = editor.value;
            try {
                // Save current state to undo stack
                pushToUndoStack(content);
                
                const formatted = formatXML(content);
                editor.value = formatted;
                markCurrentFileAsModified();
                updateStatus();
            } catch (error) {
                alert('Error: Invalid XML format in current file');
            }
        }
        


        // Panel Management Functions
        function hideAllPanels() {
            document.querySelectorAll('.tool-panel').forEach(panel => {
                panel.style.display = 'none';
            });
            document.getElementById('main-editor').style.display = 'flex';
        }
        
        function showPluginPanel() {
            hideAllPanels();
            document.getElementById('main-editor').style.display = 'none';
            document.getElementById('plugins-panel').style.display = 'flex';
        }
        
        function showFormatPanel() {
            hideAllPanels();
            document.getElementById('main-editor').style.display = 'none';
            document.getElementById('format-panel').style.display = 'flex';
        }
        
        function showComparePanel() {
            hideAllPanels();
            document.getElementById('main-editor').style.display = 'none';
            document.getElementById('compare-panel').style.display = 'flex';
        }
        
        function setCurrentAsFirstCompare() {
            const currentFile = getCurrentFile();
            if (currentFile) {
                compareFirstFileId = currentFile.id;
                renderFileTabs();
                alert(`"${currentFile.name}" set as first file to compare`);
            }
        }
        
        function compareWithFirstFile() {
            if (!compareFirstFileId) {
                alert('Please set a file as "First to Compare" first');
                return;
            }
            
            const firstFile = files.find(f => f.id === compareFirstFileId);
            const currentFile = getCurrentFile();
            
            if (!firstFile || !currentFile) {
                alert('Error: Could not find files to compare');
                return;
            }
            
            document.getElementById('compareLeft').value = firstFile.content;
            document.getElementById('compareRight').value = currentFile.content;
            updateDiff();
            showComparePanel();
        }
        
        function closeCurrentFile() {
            if (getCurrentFile()) {
                closeFile(activeFileId);
            }
        }

        function renderFileTabs() {
            const container = document.getElementById('fileTabs');
            const newBtn = container.querySelector('.new-file-btn');
            container.innerHTML = '';
            container.appendChild(newBtn);
            
            files.forEach(file => {
                const tab = document.createElement('div');
                tab.className = `file-tab ${file.id === activeFileId ? 'active' : ''} ${file.modified ? 'modified' : ''} ${file.id === compareFirstFileId ? 'compare-first' : ''}`;
                tab.onclick = () => switchToFile(file.id);
                tab.oncontextmenu = (e) => showFileTabContextMenu(e, file.id);
                
                tab.innerHTML = `
                    <span class="file-tab-name" title="${file.path || file.name}">${file.name}</span>
                    <span class="file-tab-close" onclick="event.stopPropagation(); closeFile('${file.id}')">×</span>
                `;
                
                container.appendChild(tab);
            });
        }

        // Panel Management Functions
        function hideAllPanels() {
            document.querySelectorAll('.tool-panel').forEach(panel => {
                panel.style.display = 'none';
            });
            document.getElementById('main-editor').style.display = 'flex';
        }
        
        function showPluginPanel() {
            hideAllPanels();
            document.getElementById('main-editor').style.display = 'none';
            document.getElementById('plugins-panel').style.display = 'flex';
        }
        
        function showFormatPanel() {
            hideAllPanels();
            document.getElementById('main-editor').style.display = 'none';
            document.getElementById('format-panel').style.display = 'flex';
        }
        
        function showComparePanel() {
            hideAllPanels();
            document.getElementById('main-editor').style.display = 'none';
            document.getElementById('compare-panel').style.display = 'flex';
        }
        
        function setCurrentAsFirstCompare() {
            const currentFile = getCurrentFile();
            if (currentFile) {
                compareFirstFileId = currentFile.id;
                renderFileTabs();
                alert(`"${currentFile.name}" set as first file to compare`);
            }
        }

        // Tab switching (keep for backward compatibility)
        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        // Context Menu Functions
        function showTextContextMenu(e) {
            e.preventDefault();
            const menu = document.getElementById('textContextMenu');
            menu.style.display = 'block';
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
        }

        function showFileTabContextMenu(e, fileId) {
            e.preventDefault();
            e.stopPropagation();
            currentContextFileId = fileId;
            const menu = document.getElementById('fileTabContextMenu');
            menu.style.display = 'block';
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
        }

        function hideContextMenus() {
            document.querySelectorAll('.context-menu').forEach(menu => {
                menu.style.display = 'none';
            });
        }

        // Base64 Context Menu Actions
        function base64EncodeSelection() {
            const editor = document.getElementById('editorContent');
            const selectedText = getSelectedText(editor);
            if (selectedText) {
                try {
                    // Save current state to undo stack
                    pushToUndoStack(editor.value);
                    
                    const encoded = utf8ToBase64(selectedText);
                    replaceSelectedText(editor, encoded);
                    markCurrentFileAsModified();
                } catch (error) {
                    alert('Error: Failed to encode text to Base64 - ' + error.message);
                }
            }
            hideContextMenus();
        }

        function base64DecodeSelection() {
            const editor = document.getElementById('editorContent');
            const selectedText = getSelectedText(editor);
            if (selectedText) {
                try {
                    // Save current state to undo stack
                    pushToUndoStack(editor.value);
                    
                    const decoded = base64ToUtf8(selectedText);
                    replaceSelectedText(editor, decoded);
                    markCurrentFileAsModified();
                } catch (error) {
                    alert('Error: Failed to decode Base64 - ' + error.message);
                }
            }
            hideContextMenus();
        }

        function getSelectedText(textarea) {
            return textarea.value.substring(textarea.selectionStart, textarea.selectionEnd);
        }

        function replaceSelectedText(textarea, newText) {
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            textarea.value = textarea.value.substring(0, start) + newText + textarea.value.substring(end);
            textarea.selectionStart = textarea.selectionEnd = start + newText.length;
            updateStatus();
        }

        function copySelection() {
            const editor = document.getElementById('editorContent');
            const selectedText = getSelectedText(editor);
            if (selectedText) {
                navigator.clipboard.writeText(selectedText);
            }
            hideContextMenus();
        }

        function cutSelection() {
            const editor = document.getElementById('editorContent');
            const selectedText = getSelectedText(editor);
            if (selectedText) {
                navigator.clipboard.writeText(selectedText);
                replaceSelectedText(editor, '');
                markCurrentFileAsModified();
            }
            hideContextMenus();
        }

        function pasteAtCursor() {
            navigator.clipboard.readText().then(text => {
                const editor = document.getElementById('editorContent');
                const start = editor.selectionStart;
                editor.value = editor.value.substring(0, start) + text + editor.value.substring(editor.selectionEnd);
                editor.selectionStart = editor.selectionEnd = start + text.length;
                markCurrentFileAsModified();
                updateStatus();
            });
            hideContextMenus();
        }

        // File Comparison Functions
        function setAsFirstCompare() {
            compareFirstFileId = currentContextFileId;
            renderFileTabs();
            hideContextMenus();
        }

        function compareWithFirst() {
            if (!compareFirstFileId) {
                alert('Please set a file as "First to Compare" first');
                hideContextMenus();
                return;
            }
            
            const firstFile = files.find(f => f.id === compareFirstFileId);
            const secondFile = files.find(f => f.id === currentContextFileId);
            
            if (!firstFile || !secondFile) {
                alert('Error: Could not find files to compare');
                hideContextMenus();
                return;
            }
            
            document.getElementById('compareLeft').value = firstFile.content;
            document.getElementById('compareRight').value = secondFile.content;
            hideContextMenus();
            showComparePanel();
            updateDiff();
        }

        function clearCompareSelection() {
            compareFirstFileId = null;
            renderFileTabs();
            hideContextMenus();
        }

        function renameFile() {
            const file = files.find(f => f.id === currentContextFileId);
            if (file) {
                const newName = prompt('Enter new filename:', file.name);
                if (newName && newName.trim()) {
                    file.name = newName.trim();
                    file.language = detectLanguage(file.name);
                    renderFileTabs();
                    updateStatus();
                    // Only apply syntax highlighting if this is the active file
                    if (currentContextFileId === activeFileId) {
                        applySyntaxHighlighting();
                    }
                }
            }
            hideContextMenus();
        }

        function markCurrentFileAsModified() {
            const currentFile = getCurrentFile();
            if (currentFile) {
                currentFile.modified = true;
                renderFileTabs();
            }
        }

        // Theme functions
        function toggleTheme() {
            currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
            localStorage.setItem('theme', currentTheme);
            document.documentElement.setAttribute('data-theme', currentTheme);
            document.getElementById('themeStatus').textContent = currentTheme === 'dark' ? 'Dark' : 'Light';
        }

        // Word wrap functions
        function toggleWordWrap() {
            wordWrapEnabled = !wordWrapEnabled;
            localStorage.setItem('wordWrap', wordWrapEnabled.toString());
            const editor = document.getElementById('editorContent');
            if (wordWrapEnabled) {
                editor.style.whiteSpace = 'pre-wrap';
                editor.style.wordBreak = 'break-word';
                editor.style.overflowWrap = 'break-word';
                editor.classList.add('word-wrap-enabled');
            } else {
                editor.style.whiteSpace = 'pre';
                editor.style.wordBreak = 'normal';
                editor.style.overflowWrap = 'normal';
                editor.classList.remove('word-wrap-enabled');
            }
            if (document.getElementById('wordWrapStatus')) {
                document.getElementById('wordWrapStatus').textContent = wordWrapEnabled ? 'On' : 'Off';
            }
        }

        // Add rename file function
        function renameCurrentFile() {
            const currentFile = getCurrentFile();
            if (currentFile) {
                const newName = prompt('Enter new filename:', currentFile.name);
                if (newName && newName.trim()) {
                    currentFile.name = newName.trim();
                    currentFile.language = detectLanguage(currentFile.name);
                    renderFileTabs();
                    updateStatus();
                    // Ensure editor maintains its proper styling
                    const editor = document.getElementById('editorContent');
                    editor.style.height = ''; // Reset any height changes
                    editor.style.minHeight = '400px'; // Ensure minimum height
                    applySyntaxHighlighting();
                }
            }
        }

        // Auto-save functionality
        function startAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
            }
            autoSaveInterval = setInterval(() => {
                const saveData = {
                    files: files,
                    activeFileId: activeFileId,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('autoSave', JSON.stringify(saveData));
            }, 10000); // Auto-save every 10 seconds
            document.getElementById('autoSaveStatus').textContent = 'On';
        }

        function stopAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
            }
            localStorage.removeItem('autoSave');
            document.getElementById('autoSaveStatus').textContent = 'Off';
        }

        function toggleAutoSave() {
            if (autoSaveInterval) {
                stopAutoSave();
            } else {
                startAutoSave();
            }
        }

        // Add sort lines function
        function showSortLinesDialog() {
            const sortType = prompt('Sort lines:\n1 - Ascending\n2 - Descending\n3 - Reverse order\nEnter choice (1-3):', '1');
            
            if (sortType === null) return;
            
            const editor = document.getElementById('editorContent');
            const content = editor.value;
            const lines = content.split('\n');
            
            pushToUndoStack(editor.value);
            
            let sortedLines;
            switch(sortType) {
                case '1':
                    sortedLines = lines.slice().sort();
                    break;
                case '2':
                    sortedLines = lines.slice().sort().reverse();
                    break;
                case '3':
                    sortedLines = lines.slice().reverse();
                    break;
                default:
                    alert('Invalid choice. Using ascending sort.');
                    sortedLines = lines.slice().sort();
            }
            
            editor.value = sortedLines.join('\n');
            markCurrentFileAsModified();
            updateStatus();
            applySyntaxHighlighting();
        }

        // Language detection function
        function detectLanguage(filename) {
            const ext = filename.toLowerCase().split('.').pop();
            const languages = {
                'js': 'javascript', 'ts': 'typescript', 'py': 'python',
                'html': 'html', 'css': 'css', 'json': 'json',
                'xml': 'xml', 'java': 'java', 'c': 'c', 'cpp': 'cpp',
                'cs': 'csharp', 'php': 'php', 'rb': 'ruby', 'go': 'go',
                'rs': 'rust', 'sql': 'sql', 'md': 'markdown', 'yml': 'yaml',
                'yaml': 'yaml', 'sh': 'bash', 'bat': 'batch'
            };
            return languages[ext] || 'text';
        }

        // Simple syntax highlighting
        function applySyntaxHighlighting() {
            if (!syntaxHighlightEnabled) return;
            
            const currentFile = getCurrentFile();
            if (!currentFile) return;
            
            const editor = document.getElementById('editorContent');
            
            // Reset editor classes but preserve editor styling
            editor.className = editor.className.replace(/syntax-\w+/g, '').replace(/\s+/g, ' ').trim();
            
            // Simple highlighting by adding CSS classes based on file type
            if (currentFile.language === 'javascript' || currentFile.language === 'typescript') {
                editor.classList.add('syntax-js');
            } else if (currentFile.language === 'python') {
                editor.classList.add('syntax-python');
            } else if (currentFile.language === 'html') {
                editor.classList.add('syntax-html');
            } else if (currentFile.language === 'css') {
                editor.classList.add('syntax-css');
            }
        }
        
        function toggleSyntaxHighlight() {
            syntaxHighlightEnabled = !syntaxHighlightEnabled;
            document.getElementById('syntaxStatus').textContent = syntaxHighlightEnabled ? 'On' : 'Off';
            
            const editor = document.getElementById('editorContent');
            if (syntaxHighlightEnabled) {
                applySyntaxHighlighting();
            } else {
                // Remove syntax highlighting classes but keep editor functionality
                editor.className = editor.className.replace(/syntax-\w+/g, '').replace(/\s+/g, ' ').trim();
            }
        }

        // Editor functionality
        function updateStatus() {
            const content = document.getElementById('editorContent').value;
            const editor = document.getElementById('editorContent');
            const lines = content.split('\n').length;
            const chars = content.length;
            const words = content.split(/\s+/).filter(word => word.length > 0).length;
            
            // Selection info
            const selectionLength = editor.selectionEnd - editor.selectionStart;
            
            // Cursor position
            const beforeCursor = content.substring(0, editor.selectionStart);
            const lineNumber = beforeCursor.split('\n').length;
            const lastNewline = beforeCursor.lastIndexOf('\n');
            const columnNumber = lastNewline === -1 ? beforeCursor.length + 1 : beforeCursor.length - lastNewline;
            
            document.getElementById('statusLines').textContent = `Lines: ${lines}`;
            document.getElementById('statusChars').textContent = `Characters: ${chars}`;
            document.getElementById('statusWords').textContent = `Words: ${words}`;
            document.getElementById('statusSelection').textContent = `Sel: ${selectionLength}`;
            document.getElementById('statusPosition').textContent = `Ln: ${lineNumber}, Col: ${columnNumber}`;
            
            const currentFile = getCurrentFile();
            if (currentFile) {
                document.getElementById('currentFileName').textContent = `File: ${currentFile.name}`;
                if (document.getElementById('statusLanguage')) {
                    document.getElementById('statusLanguage').textContent = currentFile.language;
                }
            }
        }

        // Event Listeners and Initialization
        let typingTimer;
        const typingDelay = 1000; // 1 second delay
        
        document.getElementById('editorContent').addEventListener('input', (e) => {
            const currentFile = getCurrentFile();
            if (currentFile) {
                // Clear previous timer
                clearTimeout(typingTimer);
                
                // Push to undo stack after user stops typing
                typingTimer = setTimeout(() => {
                    if (currentFile.content !== e.target.value) {
                        pushToUndoStack(currentFile.content);
                        currentFile.content = e.target.value;
                    }
                }, typingDelay);
            }
            
            markCurrentFileAsModified();
            updateStatus();
            applySyntaxHighlighting();
        });
        
        document.getElementById('editorContent').addEventListener('selectionchange', updateStatus);
        document.getElementById('editorContent').addEventListener('click', updateStatus);
        document.getElementById('editorContent').addEventListener('keyup', updateStatus);
        document.getElementById('editorContent').addEventListener('contextmenu', showTextContextMenu);
        document.addEventListener('click', hideContextMenus);
        
        // Enhanced keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey) {
                switch(e.key) {
                    case 'n':
                        e.preventDefault();
                        newFile();
                        break;
                    case 'o':
                        e.preventDefault();
                        openFile();
                        break;
                    case 's':
                        e.preventDefault();
                        if (e.shiftKey) {
                            saveAsFile();
                        } else {
                            saveFile();
                        }
                        break;
                    case 'w':
                        e.preventDefault();
                        if (e.shiftKey) {
                            // Close all files
                            while (files.length > 1) {
                                closeFile(files[1].id);
                            }
                        } else {
                            closeCurrentFile();
                        }
                        break;
                    case 'f':
                    case 'h':
                        e.preventDefault();
                        showFindReplaceDialog();
                        break;
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                        break;
                    case 'y':
                        e.preventDefault();
                        redo();
                        break;
                    case 'd':
                        e.preventDefault();
                        duplicateLine();
                        break;
                    case 'l':
                        e.preventDefault();
                        deleteLine();
                        break;
                    case 'r':
                        e.preventDefault();
                        if (e.shiftKey) {
                            renameCurrentFile();
                        }
                        break;
                }
            }
            
            if (e.ctrlKey && e.shiftKey) {
                switch(e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        moveLineUp();
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        moveLineDown();
                        break;
                }
            }
            
            // F11 for theme toggle
            if (e.key === 'F11') {
                e.preventDefault();
                toggleTheme();
            }
        });

        // Initialize application
        function initializeApp() {
            updateStatus();
            renderFileTabs();
            
            // Apply saved theme
            document.documentElement.setAttribute('data-theme', currentTheme);
            if (document.getElementById('themeStatus')) {
                document.getElementById('themeStatus').textContent = currentTheme === 'dark' ? 'Dark' : 'Light';
            }
            
            // Apply word wrap setting
            const editor = document.getElementById('editorContent');
            if (wordWrapEnabled) {
                editor.style.whiteSpace = 'pre-wrap';
                editor.style.wordBreak = 'break-word';
                editor.style.overflowWrap = 'break-word';
                editor.classList.add('word-wrap-enabled');
            } else {
                editor.style.whiteSpace = 'pre';
                editor.style.wordBreak = 'normal';
                editor.style.overflowWrap = 'normal';
            }
            if (document.getElementById('wordWrapStatus')) {
                document.getElementById('wordWrapStatus').textContent = wordWrapEnabled ? 'On' : 'Off';
            }
            
            // Update status indicators
            if (document.getElementById('syntaxStatus')) {
                document.getElementById('syntaxStatus').textContent = syntaxHighlightEnabled ? 'On' : 'Off';
            }
            if (document.getElementById('autoSaveStatus')) {
                document.getElementById('autoSaveStatus').textContent = autoSaveInterval ? 'On' : 'Off';
            }
            
            // Try to restore from auto-save
            const autoSaveData = localStorage.getItem('autoSave');
            if (autoSaveData) {
                try {
                    const saved = JSON.parse(autoSaveData);
                    const timeDiff = Date.now() - new Date(saved.timestamp).getTime();
                    
                    // If auto-save is less than 1 hour old, offer to restore
                    if (timeDiff < 3600000) {
                        if (confirm('Auto-saved session found. Restore it?')) {
                            files = saved.files;
                            activeFileId = saved.activeFileId;
                            renderFileTabs();
                            switchToFile(activeFileId);
                        }
                    }
                } catch (e) {
                    console.error('Failed to restore auto-save:', e);
                }
            }
            
            // Start auto-save
            startAutoSave();
            
            applySyntaxHighlighting();
        }
        
        initializeApp();

        let currentSearchIndex = 0;
        let searchMatches = [];
        let lastSearchText = '';


        
        function findAllMatches(searchText) {
            const editor = document.getElementById('editorContent');
            const content = editor.value;
            searchMatches = [];
            
            let index = 0;
            while ((index = content.indexOf(searchText, index)) !== -1) {
                searchMatches.push({
                    start: index,
                    end: index + searchText.length
                });
                index += searchText.length;
            }
        }
        
        function navigateToMatch(matchIndex) {
            if (searchMatches.length === 0 || matchIndex >= searchMatches.length) return;
            
            const editor = document.getElementById('editorContent');
            const match = searchMatches[matchIndex];
            
            // Select and scroll to the match
            editor.focus();
            editor.setSelectionRange(match.start, match.end);
            
            // Scroll the match into view
            const lines = editor.value.substring(0, match.start).split('\n');
            const lineNumber = lines.length;
            const charHeight = 20; // Approximate character height
            const scrollTop = (lineNumber - 1) * charHeight;
            editor.scrollTop = Math.max(0, scrollTop - editor.clientHeight / 2);
        }
        
        function clearSearchHighlights() {
            searchMatches = [];
            currentSearchIndex = 0;
            lastSearchText = '';
            const statusElement = document.getElementById('findReplaceStatus');
            if (statusElement) {
                statusElement.textContent = '';
            }
        }
        
        function findNext() {
            const searchText = document.getElementById('findInput').value;
            if (!searchText) {
                document.getElementById('findReplaceStatus').textContent = 'Please enter text to find';
                return;
            }

            const scope = getSelectedScope();
            if (scope === 'current') {
                // If no current search or different search text, start new search
                if (searchMatches.length === 0 || searchText !== lastSearchText) {
                    findAllMatches(searchText);
                    lastSearchText = searchText;
                    currentSearchIndex = 0;
                } else {
                    // Navigate to next match
                    currentSearchIndex = (currentSearchIndex + 1) % searchMatches.length;
                }
                
                if (searchMatches.length > 0) {
                    navigateToMatch(currentSearchIndex);
                    document.getElementById('findReplaceStatus').textContent = 
                        `Match ${currentSearchIndex + 1}/${searchMatches.length} in current file`;
                } else {
                    document.getElementById('findReplaceStatus').textContent = 'No matches found in current file';
                }
            } else {
                findInAllFiles(searchText, false);
            }
        }
        
        function findPrevious() {
            const searchText = document.getElementById('findInput').value;
            if (!searchText) {
                document.getElementById('findReplaceStatus').textContent = 'Please enter text to find';
                return;
            }

            const scope = getSelectedScope();
            if (scope === 'current') {
                // If no current search or different search text, start new search
                if (searchMatches.length === 0 || searchText !== lastSearchText) {
                    findAllMatches(searchText);
                    lastSearchText = searchText;
                    currentSearchIndex = 0;
                } else {
                    // Navigate to previous match
                    currentSearchIndex = (currentSearchIndex - 1 + searchMatches.length) % searchMatches.length;
                }
                
                if (searchMatches.length > 0) {
                    navigateToMatch(currentSearchIndex);
                    document.getElementById('findReplaceStatus').textContent = 
                        `Match ${currentSearchIndex + 1}/${searchMatches.length} in current file`;
                } else {
                    document.getElementById('findReplaceStatus').textContent = 'No matches found in current file';
                }
            } else {
                findInAllFiles(searchText, false);
            }
        }

        function handleReplace() {
            const searchText = document.getElementById('searchText').value;
            const replaceText = document.getElementById('replaceText').value;
            if (!searchText) {
                alert('Please enter text to search for');
                return;
            }
            
            const editor = document.getElementById('editorContent');
            const content = editor.value;
            const matches = content.split(searchText).length - 1;
            
            if (matches > 0) {
                const newContent = content.split(searchText).join(replaceText);
                editor.value = newContent;
                
                // Update current file content
                const currentFile = getCurrentFile();
                if (currentFile) {
                    currentFile.content = newContent;
                    markCurrentFileAsModified();
                }
                
                updateStatus();
                clearSearchHighlights();
                alert(`Replaced ${matches} occurrences of "${searchText}" with "${replaceText}"`);
            } else {
                alert(`No matches found for "${searchText}"`);
            }
        }

        // Base64 functionality
        function handleBase64Encode() {
            try {
                const input = document.getElementById('base64Input').value;
                const encoded = utf8ToBase64(input);
                document.getElementById('base64Output').value = encoded;
            } catch (error) {
                document.getElementById('base64Output').value = 'Error: Failed to encode text to Base64 - ' + error.message;
            }
        }

        function handleBase64Decode() {
            try {
                const input = document.getElementById('base64Input').value;
                const decoded = base64ToUtf8(input);
                document.getElementById('base64Output').value = decoded;
            } catch (error) {
                document.getElementById('base64Output').value = 'Error: Failed to decode Base64 - ' + error.message;
            }
        }

        // JSON functionality
        function handleFormatJSON() {
            try {
                const input = document.getElementById('jsonInput').value;
                const parsed = JSON.parse(input);
                const formatted = JSON.stringify(parsed, null, 2);
                document.getElementById('jsonOutput').value = formatted;
            } catch (error) {
                document.getElementById('jsonOutput').value = 'Error: Invalid JSON format';
            }
        }

        // XML functions
        function handleFormatXML() {
            try {
                const input = document.getElementById('jsonInput').value;
                const formatted = formatXML(input);
                document.getElementById('jsonOutput').value = formatted;
            } catch (error) {
                document.getElementById('jsonOutput').value = 'Error: Invalid XML format';
            }
        }

        function formatXML(xml) {
            const PADDING = '  '; // 2 spaces for indentation
            const reg = /(>)(<)(\/*)/g;
            let pad = 0;

            xml = xml.replace(reg, '$1\r\n$2$3');

            return xml.split('\r\n').map((node) => {
                let indent = 0;
                if (node.match(/.+<\/\w[^>]*>$/)) {
                    indent = 0;
                } else if (node.match(/^<\/\w/) && pad > 0) {
                    pad -= 1;
                } else if (node.match(/^<\w[^>]*[^\/]>.*$/)) {
                    indent = 1;
                } else {
                    indent = 0;
                }

                pad += indent;
                return PADDING.repeat(pad - indent) + node;
            }).join('\r\n');
        }



        // Diff functionality
        function computeDiff(leftText, rightText) {
            const leftLines = leftText.split('\n');
            const rightLines = rightText.split('\n');
            const result = [];
            
            let leftIndex = 0;
            let rightIndex = 0;
            
            while (leftIndex < leftLines.length || rightIndex < rightLines.length) {
                const leftLine = leftLines[leftIndex];
                const rightLine = rightLines[rightIndex];
                
                if (leftIndex >= leftLines.length) {
                    result.push({
                        type: 'insert',
                        rightContent: rightLine,
                        rightLineNumber: rightIndex + 1
                    });
                    rightIndex++;
                } else if (rightIndex >= rightLines.length) {
                    result.push({
                        type: 'delete',
                        leftContent: leftLine,
                        leftLineNumber: leftIndex + 1
                    });
                    leftIndex++;
                } else if (leftLine === rightLine) {
                    result.push({
                        type: 'equal',
                        leftContent: leftLine,
                        rightContent: rightLine,
                        leftLineNumber: leftIndex + 1,
                        rightLineNumber: rightIndex + 1
                    });
                    leftIndex++;
                    rightIndex++;
                } else {
                    // Lines are different - store original content for word-level diffing
                    result.push({
                        type: 'modify',
                        leftContent: leftLine,
                        rightContent: rightLine,
                        leftLineNumber: leftIndex + 1,
                        rightLineNumber: rightIndex + 1
                    });
                    leftIndex++;
                    rightIndex++;
                }
            }
            
            return result;
        }

        function updateDiff() {
            const leftText = document.getElementById('compareLeft').value;
            const rightText = document.getElementById('compareRight').value;
            const diffResult = computeDiff(leftText, rightText);
            
            // Update left diff view
            const diffLeft = document.getElementById('diffLeft');
            diffLeft.innerHTML = '';
            diffResult.forEach(diff => {
                const line = document.createElement('div');
                line.className = `diff-line ${diff.type}`;
                
                // Apply Myers' character-level diff for modified lines
                let leftContent = diff.leftContent !== undefined ? diff.leftContent : '';
                if (diff.type === 'modify' && diff.leftContent && diff.rightContent) {
                    leftContent = computeCharacterDiff(diff.leftContent, diff.rightContent).left;
                }
                
                line.innerHTML = `
                    <span class="line-number">${diff.leftLineNumber || ''}</span>
                    <span class="line-content">${leftContent}</span>
                `;
                diffLeft.appendChild(line);
            });
            
            // Update right diff view
            const diffRight = document.getElementById('diffRight');
            diffRight.innerHTML = '';
            diffResult.forEach(diff => {
                const line = document.createElement('div');
                line.className = `diff-line ${diff.type}`;
                
                // Apply Myers' character-level diff for modified lines
                let rightContent = diff.rightContent !== undefined ? diff.rightContent : '';
                if (diff.type === 'modify' && diff.leftContent && diff.rightContent) {
                    rightContent = computeCharacterDiff(diff.leftContent, diff.rightContent).right;
                }
                
                line.innerHTML = `
                    <span class="line-number">${diff.rightLineNumber || ''}</span>
                    <span class="line-content">${rightContent}</span>
                `;
                diffRight.appendChild(line);
            });
            
            // Update statistics
            const added = diffResult.filter(d => d.type === 'insert').length;
            const deleted = diffResult.filter(d => d.type === 'delete').length;
            const modified = diffResult.filter(d => d.type === 'modify').length;
            
            document.getElementById('compareStats').innerHTML = `
                <p><strong>Left:</strong> ${leftText.length} chars, ${leftText.split('\n').length} lines</p>
                <p><strong>Right:</strong> ${rightText.length} chars, ${rightText.split('\n').length} lines</p>
                <p><strong>Changes:</strong> 
                    <span class="stat-added">${added} added</span>, 
                    <span class="stat-deleted">${deleted} deleted</span>, 
                    <span class="stat-modified">${modified} modified</span>
                </p>
                <p><strong>Status:</strong> ${leftText === rightText ? '✅ Identical' : '❌ Different'}</p>
            `;
        }

        // Initialize diff on page load
        document.addEventListener('DOMContentLoaded', function() {
            renderFileTabs(); // Initialize file tabs
            updateStatus();
            updateDiff();
            
            // Add event listeners for compare text areas
            document.getElementById('compareLeft').addEventListener('input', updateDiff);
            document.getElementById('compareRight').addEventListener('input', updateDiff);
            
            // Initialize editor with current file content
            const currentFile = getCurrentFile();
            if (currentFile) {
                document.getElementById('editorContent').value = currentFile.content;
            }
            
            // Add input listener for editor content
            document.getElementById('editorContent').addEventListener('input', function() {
                const currentFile = getCurrentFile();
                if (currentFile) {
                    currentFile.content = this.value;
                    markCurrentFileAsModified();
                    updateStatus();
                }
            });
            
            // Click outside to hide context menus
            document.addEventListener('click', hideContextMenus);
        });

        // Find/Replace Dialog Functions
        function showFindReplaceDialog() {
            document.getElementById('findReplaceDialog').style.display = 'flex';
            document.getElementById('findInput').focus();
            clearSearchHighlights();
        }

        function closeFindReplaceDialog() {
            document.getElementById('findReplaceDialog').style.display = 'none';
            clearSearchHighlights();
        }

        function getSelectedScope() {
            return document.querySelector('input[name=\"scope\"]:checked').value;
        }

        function findFirst() {
            const searchText = document.getElementById('findInput').value;
            if (!searchText) {
                document.getElementById('findReplaceStatus').textContent = 'Please enter text to find';
                return;
            }

            const scope = getSelectedScope();
            if (scope === 'current') {
                findInCurrentFile(searchText, true);
            } else {
                findInAllFiles(searchText, true);
            }
        }

        function findInCurrentFile(searchText, isFirst = false) {
            if (isFirst || searchText !== lastSearchText) {
                findAllMatches(searchText);
                lastSearchText = searchText;
                currentSearchIndex = 0;
            }

            if (searchMatches.length > 0) {
                navigateToMatch(currentSearchIndex);
                if (!isFirst) {
                    currentSearchIndex = (currentSearchIndex + 1) % searchMatches.length;
                }
                document.getElementById('findReplaceStatus').textContent = 
                    `Found ${searchMatches.length} matches in current file. Current: ${(currentSearchIndex + 1)}/${searchMatches.length}`;
            } else {
                document.getElementById('findReplaceStatus').textContent = 'No matches found in current file';
            }
        }

        function findInAllFiles(searchText, isFirst = false) {
            let totalMatches = 0;
            let filesWithMatches = [];

            files.forEach(file => {
                const matches = file.content.split(searchText).length - 1;
                if (matches > 0) {
                    totalMatches += matches;
                    filesWithMatches.push(`${file.name} (${matches})`);
                }
            });

            if (totalMatches > 0) {
                // Also search in current file for navigation
                findInCurrentFile(searchText, isFirst);
                document.getElementById('findReplaceStatus').textContent = 
                    `Found ${totalMatches} matches across ${filesWithMatches.length} files: ${filesWithMatches.join(', ')}`;
            } else {
                document.getElementById('findReplaceStatus').textContent = 'No matches found in any opened files';
            }
        }

        function replaceNext() {
            const searchText = document.getElementById('findInput').value;
            const replaceText = document.getElementById('replaceInput').value;
            
            if (!searchText) {
                document.getElementById('findReplaceStatus').textContent = 'Please enter text to find';
                return;
            }

            const scope = getSelectedScope();
            if (scope === 'current') {
                const editor = document.getElementById('editorContent');
                
                // First, ensure we have current matches
                if (searchMatches.length === 0 || searchText !== lastSearchText) {
                    findAllMatches(searchText);
                    lastSearchText = searchText;
                    currentSearchIndex = 0;
                }
                
                if (searchMatches.length === 0) {
                    document.getElementById('findReplaceStatus').textContent = 'No matches found to replace';
                    return;
                }
                
                // Get the current match position
                const currentMatch = searchMatches[currentSearchIndex];
                const start = currentMatch.start;
                const end = currentMatch.end;
                
                // Replace the current match
                editor.value = editor.value.substring(0, start) + replaceText + editor.value.substring(end);
                
                // Update file content
                const currentFile = getCurrentFile();
                if (currentFile) {
                    currentFile.content = editor.value;
                    markCurrentFileAsModified();
                }
                
                updateStatus();
                
                // Refresh matches after replacement (positions may have changed)
                findAllMatches(searchText);
                
                // Position cursor after the replacement and find next
                editor.selectionStart = editor.selectionEnd = start + replaceText.length;
                
                if (searchMatches.length > 0) {
                    // Find the next match after the current position
                    let nextIndex = 0;
                    for (let i = 0; i < searchMatches.length; i++) {
                        if (searchMatches[i].start >= start + replaceText.length) {
                            nextIndex = i;
                            break;
                        }
                    }
                    currentSearchIndex = nextIndex;
                    navigateToMatch(currentSearchIndex);
                    document.getElementById('findReplaceStatus').textContent = 
                        `Replaced 1 occurrence. Match ${currentSearchIndex + 1}/${searchMatches.length}`;
                } else {
                    document.getElementById('findReplaceStatus').textContent = 'Replaced last occurrence';
                }
            } else {
                document.getElementById('findReplaceStatus').textContent = 'Use "Replace All" for multiple files';
            }
        }

        function replaceAll() {
            const searchText = document.getElementById('findInput').value;
            const replaceText = document.getElementById('replaceInput').value;
            
            if (!searchText) {
                document.getElementById('findReplaceStatus').textContent = 'Please enter text to find';
                return;
            }

            const scope = getSelectedScope();
            if (scope === 'current') {
                replaceInCurrentFile(searchText, replaceText, true);
            } else {
                replaceInAllFiles(searchText, replaceText);
            }
        }

        function replaceInCurrentFile(searchText, replaceText, replaceAll = true) {
            const editor = document.getElementById('editorContent');
            const content = editor.value;

            if (replaceAll) {
                const matches = content.split(searchText).length - 1;
                if (matches > 0) {
                    const newContent = content.split(searchText).join(replaceText);
                    editor.value = newContent;
                    
                    const currentFile = getCurrentFile();
                    if (currentFile) {
                        currentFile.content = newContent;
                        markCurrentFileAsModified();
                    }
                    
                    updateStatus();
                    clearSearchHighlights();
                    document.getElementById('findReplaceStatus').textContent = 
                        `Replaced ${matches} occurrences in current file`;
                } else {
                    document.getElementById('findReplaceStatus').textContent = 'No matches found to replace in current file';
                }
            } else {
                // Replace only the current selection if it matches
                const start = editor.selectionStart;
                const end = editor.selectionEnd;
                const selectedText = editor.value.substring(start, end);
                
                if (selectedText === searchText) {
                    editor.value = editor.value.substring(0, start) + replaceText + editor.value.substring(end);
                    editor.selectionStart = editor.selectionEnd = start + replaceText.length;
                    
                    const currentFile = getCurrentFile();
                    if (currentFile) {
                        currentFile.content = editor.value;
                        markCurrentFileAsModified();
                    }
                    
                    updateStatus();
                    document.getElementById('findReplaceStatus').textContent = 'Replaced 1 occurrence';
                    
                    // Find next occurrence
                    findNext();
                } else {
                    findNext();
                }
            }
        }

        function replaceInAllFiles(searchText, replaceText) {
            let totalReplacements = 0;
            let modifiedFiles = [];

            files.forEach(file => {
                const matches = file.content.split(searchText).length - 1;
                if (matches > 0) {
                    file.content = file.content.split(searchText).join(replaceText);
                    file.modified = true;
                    totalReplacements += matches;
                    modifiedFiles.push(`${file.name} (${matches})`);
                }
            });

            if (totalReplacements > 0) {
                // Update current editor if it's one of the modified files
                const currentFile = getCurrentFile();
                if (currentFile) {
                    document.getElementById('editorContent').value = currentFile.content;
                }
                
                renderFileTabs();
                updateStatus();
                clearSearchHighlights();
                document.getElementById('findReplaceStatus').textContent = 
                    `Replaced ${totalReplacements} occurrences across ${modifiedFiles.length} files: ${modifiedFiles.join(', ')}`;
            } else {
                document.getElementById('findReplaceStatus').textContent = 'No matches found to replace in any opened files';
            }
        }

        // Myers' diff algorithm for efficient character-level diffing
        function myersDiff(left, right) {
            const N = left.length;
            const M = right.length;
            const MAX = N + M;
            
            // Trace array for backtracking
            const traces = [];
            const V = {};
            V[1] = 0;
            
            // Forward search
            for (let D = 0; D <= MAX; D++) {
                traces.push({...V});
                
                for (let k = -D; k <= D; k += 2) {
                    let x;
                    if (k === -D || (k !== D && V[k-1] < V[k+1])) {
                        x = V[k+1];
                    } else {
                        x = V[k-1] + 1;
                    }
                    
                    let y = x - k;
                    
                    // Extend diagonal as far as possible
                    while (x < N && y < M && left[x] === right[y]) {
                        x++;
                        y++;
                    }
                    
                    V[k] = x;
                    
                    if (x >= N && y >= M) {
                        return buildDiff(left, right, traces, D);
                    }
                }
            }
            
            return buildDiff(left, right, traces, MAX);
        }
        
        function buildDiff(left, right, traces, D) {
            const result = [];
            let x = left.length;
            let y = right.length;
            
            for (let d = D; d >= 0; d--) {
                const V = traces[d];
                const k = x - y;
                
                let prevK;
                if (k === -d || (k !== d && V[k-1] < V[k+1])) {
                    prevK = k + 1;
                } else {
                    prevK = k - 1;
                }
                
                const prevX = V[prevK];
                const prevY = prevX - prevK;
                
                // Diagonal moves (matches)
                while (x > prevX && y > prevY) {
                    result.unshift({type: 'match', leftChar: left[x-1], rightChar: right[y-1]});
                    x--;
                    y--;
                }
                
                if (d > 0) {
                    // Insert or delete
                    if (x > prevX) {
                        result.unshift({type: 'delete', leftChar: left[x-1]});
                        x--;
                    } else {
                        result.unshift({type: 'insert', rightChar: right[y-1]});
                        y--;
                    }
                }
            }
            
            return result;
        }
        
        // Convert Myers' diff to HTML with yellow highlighting for all changes
        function myersDiffToHtml(diff, side) {
            return diff.map(op => {
                if (op.type === 'match') {
                    return side === 'left' ? op.leftChar : op.rightChar;
                } else if (op.type === 'delete') {
                    return side === 'left' ? `<span style="background-color: #FFA500;">${op.leftChar}</span>` : '';
                } else if (op.type === 'insert') {
                    return side === 'right' ? `<span style="background-color: #FFA500;">${op.rightChar}</span>` : '';
                }
                return '';
            }).join('');
        }
        
        // Optimized character diff using Myers' algorithm
        function computeCharacterDiff(leftLine, rightLine) {
            const diff = myersDiff(leftLine, rightLine);
            return {
                left: myersDiffToHtml(diff, 'left'),
                right: myersDiffToHtml(diff, 'right')
            };
        }



        // Diff functionality
        function computeDiff(leftText, rightText) {
            const leftLines = leftText.split('\n');
            const rightLines = rightText.split('\n');
            const result = [];
            
            let leftIndex = 0;
            let rightIndex = 0;
            
            while (leftIndex < leftLines.length || rightIndex < rightLines.length) {
                const leftLine = leftLines[leftIndex];
                const rightLine = rightLines[rightIndex];
                
                if (leftIndex >= leftLines.length) {
                    result.push({
                        type: 'insert',
                        rightContent: rightLine,
                        rightLineNumber: rightIndex + 1
                    });
                    rightIndex++;
                } else if (rightIndex >= rightLines.length) {
                    result.push({
                        type: 'delete',
                        leftContent: leftLine,
                        leftLineNumber: leftIndex + 1
                    });
                    leftIndex++;
                } else if (leftLine === rightLine) {
                    result.push({
                        type: 'equal',
                        leftContent: leftLine,
                        rightContent: rightLine,
                        leftLineNumber: leftIndex + 1,
                        rightLineNumber: rightIndex + 1
                    });
                    leftIndex++;
                    rightIndex++;
                } else {
                    let foundLeftInRight = -1;
                    let foundRightInLeft = -1;
                    
                    for (let i = 1; i <= Math.min(5, Math.max(leftLines.length - leftIndex, rightLines.length - rightIndex)); i++) {
                        if (foundLeftInRight === -1 && rightIndex + i < rightLines.length && leftLine === rightLines[rightIndex + i]) {
                            foundLeftInRight = i;
                        }
                        if (foundRightInLeft === -1 && leftIndex + i < leftLines.length && rightLine === leftLines[leftIndex + i]) {
                            foundRightInLeft = i;
                        }
                    }
                    
                    if (foundLeftInRight === 1 && foundRightInLeft === -1) {
                        result.push({
                            type: 'insert',
                            rightContent: rightLine,
                            rightLineNumber: rightIndex + 1
                        });
                        rightIndex++;
                    } else if (foundRightInLeft === 1 && foundLeftInRight === -1) {
                        result.push({
                            type: 'delete',
                            leftContent: leftLine,
                            leftLineNumber: leftIndex + 1
                        });
                        leftIndex++;
                    } else {
                        result.push({
                            type: 'modify',
                            leftContent: leftLine,
                            rightContent: rightLine,
                            leftLineNumber: leftIndex + 1,
                            rightLineNumber: rightIndex + 1
                        });
                        leftIndex++;
                        rightIndex++;
                    }
                }
            }
            
            return result;
        }

    </script>

</body>
</html>